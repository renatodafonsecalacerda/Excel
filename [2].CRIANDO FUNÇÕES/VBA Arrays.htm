
<!-- saved from url=(0043)http://www.cpearson.com/excel/vbaarrays.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">

<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 12.0">
<meta name="Keywords" content="Excel, Microsoft Excel, VBA, Excel97, Excel2000, Excel Formulas, Excel Macros, Excel Functions">
<meta name="Description" content="From Pearson Software Consulting, your complete resource for Excel solutions.">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>VBA Arrays</title>
<link rel="stylesheet" type="text/css" href="./VBA Arrays_files/Global.css">
<meta name="Microsoft Border" content="none">
<script>
EraseDefinition="The Erase command clears an array. For static arrays, it restores all elements to their default values (0s or vbNullStrings or Nothing). For dynamic arrays, it deallocates the array. You must ReDim a dynamic array in order to use it after an Erase operation."
</script></head>

<body bgcolor="#FFFFFF" text="#800000" vlink="#003366" leftmargin="10" link="#FF0000">

<p align="center" style="border-top-style: double; border-top-color: #800000; border-bottom-style: double; border-bottom-color: #800000; padding-top: 2; padding-bottom: 2">
<font size="5" face="Arial"><i>Pearson Software Consulting Services</i></font></p>
<p style="background-color: #800000; color: #FFFF99; padding-left: 10; padding-top: 2; padding-bottom: 2"><font size="6" face="Arial">&nbsp;&nbsp;&nbsp;
Functions For VBA Arrays</font></p>
<table border="0" width="90%" cellspacing="1">
  <tbody><tr>
    <td width="5%"></td>
    <td width="93%"></td>
    <td width="10%"></td>
  </tr>
  <tr>
    <td width="5%"><font face="Arial">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font></td>
    <td width="93%">
    <font face="Arial">If you're writing anything but the most trivial VBA 
	procedures, it is quite likely that you will be using arrays in your VBA 
	code to store data or series of related data.
	This page describes nearly 40 functions you can use to get information about 
	and manipulate arrays. It is assumed that you know the basics 
	of VBA arrays. For information about passing and returning arrays to and 
	from procedures, see the <a href="http://www.cpearson.com/excel/PassingAndReturningArrays.htm">Passing And 
	Returning Arrays With Functions page</a>.<br>
	<br>
	The following terminology used on this page:</font><blockquote>
		<p><font face="Arial">A <b> <i>static</i></b> array is an array that is sized in the </font>
		<font face="Courier New" color="#003366">Dim</font><font face="Arial"> statement that 
	declares the array. E.g., <br></font>
		<font face="Courier New" color="#003366">Dim StaticArray(1 To 10) As 
	Long<br></font><font face="Arial">You cannot change the size or data type of a static array. 
		When you Erase a static array, no memory is freed. Erase simple set all 
		the elements to their default value (0, vbNullString, Empty, or Nothing, 
		depending on the data type of the array).</font></p>
		<p><font face="Arial">A <b> <i>dynamic</i></b> array is an array that is not sized 
	in the 
		</font>
		<font face="Courier New" color="#003366">Dim</font><font face="Arial"> statement. Instead, it is sized with the
		</font><font face="Courier New" color="#003366">ReDim</font><font face="Arial"> statement. E.g., <br>
		</font><font face="Courier New" color="#003366">Dim DynamicArray() As Long<br>ReDim DynamicArray(1 To 10)<br>
		</font><font face="Arial">You can change the size of a dynamic array, but 
	not the data type. When you Erase a dynamic array, the memory allocated to 
		the array is released. You must ReDim the array in order to use it after 
		it has been Erased.</font></p>
		<p><font face="Arial">An array is <b> <i>allocated</i></b> if it is either a static 
	array or a dynamic array that has been sized with the </font><font face="Courier New" color="#003366">ReDim</font><font face="Arial"> statement.&nbsp;
		<br>Static arrays are always allocated and never empty.<br>
		<br>
		An array is <b> <i>
		empty</i></b> or <b> <i>unallocated</i></b> if it 
	is a dynamic array that has 
		not yet been sized with the </font><font face="Courier New" color="#003366">ReDim</font><font face="Arial"> statement or 
	that has been deallocated with the </font>
		<font face="Courier New" color="#003366"><a href="javascript:popup.TextPopup(EraseDefinition,"Arial,9",10,10,10,10)">Erase</a></font><font face="Arial"> statement.&nbsp;
		Static arrays are never 
	unallocated or empty.</font></p>
		<p><font face="Arial">An <b><i>element</i></b> is one specific item in 
		an array of items.</font></p>
	</blockquote>
	<p><font face="Arial">This page describes about 30 functions that you can 
	use to get information about and manipulate arrays.&nbsp; You can download a
	<a href="http://www.cpearson.com/Zips/modArraySupport.zip">bas module file containing the 
	procedures here</a>.&nbsp; The downloadable file contains two modules: 
	modArraySupport, which contains all of the VBA code, and modDemo which 
	contains procedures testing and illustrating the function in modArraySupport. 
	You do not need to include modDemo in your project in order to use 
	modArraySupport.</font></p>
	<p><font face="Arial">These functions call upon one another, so it is 
	recommended that you Import the entire module file into your project.</font></p>
	<p><font face="Arial">This page describes the following procedures:</font></p>
	<blockquote>
		<p><font face="Courier New" color="#003366">AreDataTypesCompatible<br>
		ChangeBoundsOfArray<br>
		CombineTwoDArrays<br>
		CompareArrays<br>ConcatenateArrays<br>CopyArray<br>
		CopyArraySubSetToArray<br>CopyNonNothingObjectsToArray<br>
		DataTypeOfArray<br>DeleteArrayElement<br>
		ExpandArray<br>FirstNonEmptyStringIndexInArray<br>
		GetColumn<br>
		GetRow<br>
		InsertElementIntoArray<br>IsArrayAllDefault<br>IsArrayAllNumeric<br>
		IsArrayAllocated<br>IsArrayDynamic<br>IsArrayEmpty<br>IsArrayObjects<br>
		IsArraySorted<br>
		IsNumericDataType<br>IsVariantArrayConsistent<br>IsVariantArrayNumeric<br>
		MoveEmptyStringsToEndOfArray<br>NumberOfArrayDimensions<br>NumElements<br>
		ResetVariantArrayToDefaults<br>ReverseArrayInPlace<br>
		ReverseArrayOfObjectsInPlace<br>SetObjectArrayToNothing<br>
		SetVariableToDefault<br>
		SwapArrayRows<br>
		SwapArrayColumns<br>TransposeArray<br>VectorsToArray</font><font face="Arial"><br>&nbsp;</font></p>
	</blockquote>
	<p><font face="Arial">If you are new VBA (or VB) arrays, but have experience 
	with arrays in other programming languages (e.g., C), you will find that VBA arrays 
	work pretty much the same. The primary difference is that a VBA array is 
	more than just a sequential series of bytes.&nbsp; A VBA array is actually a 
	structure called a SAFEARRAY which contains information about the array 
	including the number of dimensions and the number of elements in each 
	dimension. This structure 
	includes a pointer variable that points to the to the actual data. Any array operation in your 
	VBA code uses the appropriate SAFEARRAY API functions.&nbsp; These are
	<a href="http://msdn2.microsoft.com/en-us/library/ms221482.aspx">documented 
	on MSDN</a>. While this may add some overhead processing to the project, it 
	prevents common bugs that are frequent in standard arrays, such as going beyond 
	the end of the array. An attempt to access an element beyond the end of the 
	array will result in a trappable run-time error "9 -- Subscript out of 
	range". </font></p>
	<p><font face="Arial">Another significant difference between VB/VBA arrays 
	and conventional (e.g., C) arrays, is that you can specify any value for the lower and 
	upper bounds of the array. Element 0 need not be the first element in the 
	array. For example, the following is perfectly legal code (as long as the 
	lower bound is less than or equal to the upper bound -- you'll receive a 
	compiler error if the lower bound is greater the upper bound):</font></p>
	<pre><font color="#003366">Dim N As Long
Dim Arr(-100 To -51) As Long
Debug.Print "LBound: " &amp; CStr(LBound(Arr)), _
    "UBound: " &amp; CStr(UBound(Arr)), _
    "NumElements: " &amp; CStr(UBound(Arr) - LBound(Arr) + 1)
For N = LBound(Arr) To UBound(Arr)
    Arr(N) = N * 100
Next N</font></pre>
	<p><font face="Arial">While I have never found the need to use a lower bound 
	other than 0 or 1, there are circumstances in which this might be useful, 
	and VB/VBA array will support it.<br>
	<br>
	The final significant difference is that if you don't 
	explicitly declare the lower bound of an array, the lower bound will be 
	assumed to be either 0 or 1, depending on value of 
	the Option Base statement, if present. If Option Base is not present in the 
	module, 0 is assumed.&nbsp; For example, the code</font></p>
	<pre><font color="#003366">Dim Arr(10) As Long</font></pre>
	<p><font face="Arial">declares an array of either 10 or 11 elements. Note 
	that the declaration does <b><i>not</i></b> specify the number of elements 
	in the array. Instead, it specifies the upper bound of the array.&nbsp; If your 
	module does not contain an Option Base statement, the lower bound is assumed to 
	be zero, and the declaration above is the same as</font></p>
	<pre><font color="#003366">Dim Arr(0 To 10) As Long</font></pre>
	<p><font face="Arial">If you have an Option Base statement of 0 or 1, the 
	lower bound of the array is set to that value.&nbsp; Thus, the code </font></p>
	<pre><font color="#003366">Dim Arr(10) As Long</font></pre>

<font face="Arial" size="3">is is the equivalent of either</font><pre><font color="#003366">Dim Arr(0 To 10) As Long
' or
Dim Arr(1 To 10) As Long</font></pre><p><font face="Arial">depending on the value of the Option Base. It is, in my opinion, very poor programming practice to omit the lower bound and declare only the upper bound. Omitting the lower bound will lead to bugs when you copy/paste code between modules and projects. You should always explicitly specify both the lower and upper bound for the array, either in the Dim or a ReDim statement.&nbsp; </font></p><p><font face="Arial">Finally, because the lower and upper bounds of a dynamic array may be changed at run-time with the ReDim statement, you should <i>always</i> use LBound and UBound when looping through an array. Never hard-code array limits. E.g., </font></p><pre><font color="#003366">Dim N As Long
Dim Arr(-100 To -51) As Long
For N = LBound(Arr) To UBound(Arr)
&nbsp;&nbsp;&nbsp; ' do something with Arr(N)
Next N</font></pre><p><font face="Arial">Prior to attempting to loop through a dynamically declared array, you should test to ensure that the array has, in fact, been allocated. You can use the IsArrayAllocated function shown below to test this condition:</font></p><pre><font color="#003366">Dim Arr() As Long
If IsArrayAllocated(Arr:=Arr) = True Then
&nbsp;&nbsp;&nbsp; ' loop through the array
Else
&nbsp;&nbsp;&nbsp; ' code for unallocated array
End If</font></pre><p><font face="Arial"><br>
	<font size="5">Function Descriptions</font></font></p><p><font face="Arial">The function descriptions are as follows:</font></p><p><font face="Courier New" color="#003366">AreDataTypesCompatible</font></p><pre><font color="#003366">Public Function AreDataTypesCompatible(DestVar As Variant, SourceVar As Variant) As Boolean</font></pre><p><font face="Arial">This function examines two variables,&nbsp; DestVar 
	and SourceVar, and determines whether they are compatible. The variables are 
	compatible if both variables are the same data type, or if the value in 
	SourceVar can be stored in DestVar without losing precision or encountering 
	an overflow error. For example, a Source Integer is compatible with a Dest 
	Long because an Integer can be stored in a Long variable without loss of 
	precision or overflow. A Source Double is not compatible with a Dest Long 
	because the Double would lose precision (the fractional part of the number 
	will be lost) and its conversion might cause an overflow error. </font></p><p><font face="Courier New" color="#003366">ChangeBoundsOfArray</font></p><pre><font color="#003366">Public Function ChangeBoundsOfArray(InputArr As Variant, _
&nbsp;&nbsp;&nbsp; NewLowerBound As Long, NewUpperBound) As Boolean</font></pre><p><font face="Arial">This function changes the upper and lower bounds of InputArray. Existing data in InputArr is preserved. InputArr&nbsp; must be a dynamic, allocated single-dimensional array. If the new size of the array (</font><font face="Courier New" color="#003366">NewUpperBound-NewLowerBound+1</font><font face="Arial">) is greater than the original array, the additional elements on the right end of the array are set to the default value of the data type of the array (0, vbNullString, Empty, or Nothing). If the new size of the array is less than the size of the original array, the new array will contain only the left-most values of the original array. Elements to the right are lost. The elements of the array may be simple type variables (e.g., Longs, Strings), Objects, or Arrays. User-Defined Type are not allowed.&nbsp; An error will occur if InputArr is not an array, if InputArr is a static array, if InputArr is not allocated, if NewLowerBound is greater than NewUpperBound, or if InputArr is not single-dimensional. The function returns False if an error occurred, or True if the operation was successful.</font></p><p><font face="Courier New" color="#003366">CombineTwoDArrays</font></p><pre><font color="#003366">Public Function CombineTwoDArrays(Arr1 As Variant, _
&nbsp;&nbsp;&nbsp; Arr2 As Variant) As Variant</font></pre><p><font face="Arial">This function combines two 2-dimensional arrays into a single array.&nbsp; The function returns a Variant containing an array that is the combination of Arr1 and Arr2. If an error occurs, the result is NULL. Both dimensions of both Arr1 and Arr2 must have the same LBound -- that is, all 4 LBounds must be equal.&nbsp; The result array is Arr1 with addition rows appended from Arr2. For example, the arrays<br><br></font><font face="Courier New" color="#003366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e&nbsp;&nbsp; f <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp; d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g&nbsp;&nbsp; h</font></p><p><font face="Arial">are combined to create an array:</font></p><p><font face="Courier New" color="#003366">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp; d<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e&nbsp;&nbsp;&nbsp; f<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g&nbsp;&nbsp;&nbsp; h</font></p><p><font face="Arial">You can nest calls to CombineTwoDArrays to concatenate several arrays into a singe array. For example, </font></p><pre><font color="#003366">&nbsp;&nbsp;&nbsp; V = CombineTwoDArrays(CombineTwoDArrays(CombineTwoDArrays(A, B), C), D)</font></pre><p><font face="Arial">&nbsp;</font><font face="Courier New" color="#003366"><br>CompareArrays</font></p><pre><font color="#003366">Public Function CompareArrays(Array1 As Variant, Array2 As Variant, _
&nbsp;&nbsp;&nbsp; ResultArray As Variant, Optional CompareMode As VbCompareMethod = vbTextCompare) As Boolean</font></pre><p><font face="Arial">This function compares two array, Array1 and Array2, and populates ResultArray with the comparison results of pair of corresponding elements in Array1 and Array2. Each element in Array1 is compare to the corresponding element in Array2, and the corresponding element in ResultArray is set to -1 if the element in Array1 is less than the element in Array2, 0 if the two elements are equal, and +1 if the element in Array1 is greater than the element in Array2. Array1 and Array2 have the same LBound and have the same number of elements. ResultArray must be a dynamic array of a numeric data type (typically Variant or Long).&nbsp; If Array1 and Array2 are numeric types, comparison is done with the "&gt;"&nbsp; and "&lt;" operators. If Array1 and Array2 are string arrays, comparison is done with StrComp and the text-comparison mode (case-sensitive or case-insensitive) is determined by the CompareMode parameter. </font></p>
	<p><font face="Courier New" color="#003366">ConcatenateArrays</font>
	</p><pre><font color="#003366">Public Function ConcatenateArrays(ResultArray As Variant, ArrayToAppend As Variant, _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optional NoCompatabilityCheck As Boolean = False) As Boolean</font></pre><p><font face="Arial">This function appends the the ArrayToAppend array to the end of 
	ResultArray. The 
	Result array, which will hold its original values and the values of ArrayToAppend at the end of the array, must be a dynamic array. The Result 
	array will be resized to hold its original data plus the data in the 
	ArrayToAppend array. ArrayToAppend may be either a static or dynamic array. 
	Either or both the Result array and the ArrayToAppend array may be 
	unallocated. If the Result array is unallocated, and ArrayToAppend is 
	allocated, the Result array is set to the same size as ArrayToAppend, and 
	the LBound and UBound of the Result array will be the same as ArrayToAppend. 
	If the ArrayToAppend is unallocated, the Result array is left intact and the 
	function terminates. If both arrays are unallocated, no action is taken, the 
	arrays remain unchanged, and the procedure terminates. </font>
	</p><p><font face="Arial">By default, ConcatenateArrays ensures that the data 
	types of ResultArray and the ArrayToAppend array are equal or 
	compatible. A destination element is compatible with a source element if the 
	value of source element can be stored in the destination element without 
	loss of precision or an overflow. For example, a destination Long is 
	compatible with a source Integer because you can store an Integer in a Long 
	with no loss of information or overflow. A destination Long is not 
	compatible with a source Double because a Double cannot be stored in a Long 
	without loss of information (the decimal portion will be lost) or 
	possibility of overflow. The function </font>
	<font face="Courier New" color="#003366">AreDataTypesCompatible</font><font face="Arial"> 
	is used to test compatible data types.&nbsp; You can skip the compatibility 
	test by setting the NoCompatibilityCheck parameter to True.&nbsp; Note, 
	though, that this may cause information to be lost (decimal places may be 
	lost when copying a Single or Double to an Integer or Long) or you may 
	encounter an overflow condition, in which case that element of the 
	destination array will be set to 0. If an overflow error occurs, the 
	procedure ignores it and sets the destination array element to 0.</font></p><p><font face="Courier New" color="#003366">CopyArray</font></p><pre><font color="#003366">Public Function CopyArray(DestinationArray As Variant, SourceArray As Variant, _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optional NoCompatabilityCheck As Boolean = False) As Boolean</font></pre><p><font face="Arial">This function copies SourceArray to DestinationArray.&nbsp; 
	Unfortunately, VBA does not allow you to copy one array to another with a 
	simple assignment statement. You must copy the array element by element.&nbsp; 
	If DestinationArray is dynamic, it is resized to hold all of the values 
	in SourceArray. The DestinationArray will have the same lower and 
	upper bounds of the SourceArray. If the DestinationArray is static, and 
	the Source array has more elements than the Destination array, only the left-most elements of SourceArray are copied to fill DestinationArray. If 
	DestinationArray is static and the SourceArray has fewer elements that 
	the Destination array, the right-most elements of Destination array are left 
	intact. The DestinationArray is not resized to match the SourceArray.&nbsp; 
	If the SourceArray is empty (unallocated), the Destination array is left 
	intact. If both the SourceArray and the DestinationArray are unallocated, 
	the function exits and neither array is modified. </font></p>
	<p><font face="Arial">By default, CopyArray ensures that the data types of 
	the Source and Destination arrays are equal or compatible. A destination 
	element is compatible with a source element if the value of source element 
	can be stored in the destination element without loss of precision or an 
	overflow. For example, a destination Long is compatible with a source 
	Integer because you can store an Integer in a Long with no loss of 
	information or overflow. A destination Long is not compatible with a source 
	Double because a Double cannot be stored in a Long without loss of 
	information (the decimal portion will be lost) or possibility of overflow. 
	The function </font><font face="Courier New" color="#003366">
	AreDataTypesCompatible</font><font face="Arial"> is used to test compatible 
	data types.&nbsp; You can skip the compatibility test by setting the 
	NoCompatibilityCheck parameter to True.&nbsp; Note, though, that this may 
	cause information to be lost (decimal places may be lost when copying a 
	Single or Double to an Integer or Long) or you may encounter an overflow 
	condition, in which case that element of the destination array will be set 
	to 0. If an overflow error occurs, the procedure ignores it and sets the 
	destination array element to 0.</font></p><p><font face="Courier New" color="#003366">CopyArraySubSetToArray</font></p><pre><font color="#003366">Public Function CopyArraySubSetToArray(InputArray As Variant, ResultArray As Variant, _
&nbsp;&nbsp;&nbsp; FirstElementToCopy As Long, LastElementToCopy As Long, DestinationElement As Long) As Boolean</font></pre><p><font face="Arial">This function copies a subset of InputArray to a location in ResultArray. 
	The elements between FirstElementToCopy and LastElementToCopy (inclusive) of 
	InputArray are copied to ResultArray, starting at DestinationElement. 
	Existing data in ResultArray is overwritten. If ResultArray is not large 
	enough to store the new data, it is resized appropriately if it is a dynamic 
	array. If ResultArray is a static array and is not large enough to hold the 
	new data, an error occurs and the function returns False. Both InputArray 
	and ResultArray may be dynamic arrays, but InputArray must be allocated. 
	ResultArray may be unallocated. If ResultArray is unallocated, it is resized 
	with an LBound of 1 and a UBound of DestinationElement + NumElementsToCopy - 
	1. The elements to the left of DestinationElement are default values for the 
	arrays data type (0, vbNullString, Empty, or Nothing).&nbsp; No type 
	checking is done when copying the elements from one array to another. If 
	InputArray is not compatible with ResultArray, no error is raised and the 
	value in the ResultArray will be the default value for the data type of the 
	array (0, vbNullString, Empty, or Nothing).&nbsp; </font></p>
	<p><font face="Courier New" color="#003366">CopyNonNothingObjectToArray</font></p><pre><font color="#003366">Public Function CopyNonNothingObjectsToArray(ByRef SourceArray As Variant, _
&nbsp;&nbsp;&nbsp; ByRef ResultArray As Variant, Optional NoAlerts As Boolean = False) As Boolean</font></pre><p><font face="Arial">This function copies all objects in SourceArray that are not Nothing to a 
	new ResultArray. ResultArray must be declared as a dynamic array of Objects 
	or Variants. SourceArray must contain all object-type variables (although 
	the object types may be mixed -- the array may contain more than one type of 
	object) or Nothing objects. An error will occur if a non-object variable is 
	found in SourceArray.<br>
&nbsp;</font></p>
	<p><font face="Courier New" color="#003366"><font size="4">
	DataTypeOfArray</font></font></p><pre><font color="#003366">Public Function DataTypeOfArray(Arr As Variant) As VbVarType</font></pre><p><font face="Arial">This function returns the data type (a 
	</font><font face="Courier New" color="#003366">VbVarType</font><font face="Arial"> 
	value) of the specified array. If the specified array is a simple array,<br>
	either single- or multi-dimensional, the function returns its data type. The 
	specified array may be unallocated.&nbsp;  
	If the variable passed in to   
	</font>
	<font face="Courier New" color="#003366">DataTypeOfArray</font><font face="Arial"> 
	is not an array, the function returns -1. 
	If the specified
	array is an array of arrays, the result is 
	</font><font face="Courier New" color="#003366"> 
	vbArray</font><font face="Arial">. For example,<br>
	</font><font face="Courier New" color="#003366">Dim V(1 to 5) As String<br>
	Dim R As VbVarType<br>
	R = DataTypeOfArray(V)&nbsp; ' returns vbString = 8</font></p><p>&nbsp;</p>
	<p><font size="4" face="Courier New" color="#003366">
	DeleteArrayElement</font></p><pre><font color="#003366">Public Function DeleteArrayElement(InputArray As Variant, ElementNumber As Long, _
&nbsp;&nbsp;&nbsp; Optional ResizeDynamic As Boolean = False) As Boolean</font></pre><p><font face="Arial">This function deletes the specified element from 
	the InputArray, shifting everything to the right of the deleted element one 
	position to the left. The last element of the array is set to the 
	appropriate default value (0, vbNullString, Empty, or Nothing) depending on 
	the type of data in the array. The data type is determined by the last 
	element in the array. By default, the size of the array is not changed. If 
	the ResizeDynamic parameter is True and InputArray is a dynamic array, it 
	will be resized down by one to remove the last element of the array. If the input array 
            has one element, it is Erased.</font></p><p><font face="Courier New" color="#003366" size="4">ExpandArray</font></p><pre><font color="#003366">Function ExpandArray(Arr As Variant, WhichDim As Long, AdditionalElements As Long, _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FillValue As Variant) As Variant</font></pre><p><font face="Arial">This function expands a two-dimensional array in either dimension. It returns an array with additional rows or columns. Rows are added at the bottom or the array, and columns are added at the right of the array. Arr is the original array. This array is not modified in any way. WhichDim indicates whether to add additional rows (WhichDim = 1) or additional columns (WhichDim = 2). AdditionalElements indicates the number of additional rows or columns to add to Arr. The new array elements are initialized with the value in FillValue. The function returns NULL if an error occurred. This function may be nested to add both rows and columns. The following code adds 3 rows and then 4 columns to the array A and puts the result array in C.</font></p><pre><font color="#003366">Dim A()
Dim B()
Dim C()
'''''''''''''''''''''''''''''''''''''''''''''''''''''
' Redim A, B, and C, and give them some values here.
'''''''''''''''''''''''''''''''''''''''''''''''''''''
C = ExpandArray(ExpandArray(Arr:=A, WhichDim:=1, AdditionalElements:=3, FillValue:="R"), _
&nbsp;&nbsp;&nbsp; WhichDim:=2, AdditionalElements:=4, FillValue:="C")</font></pre><p>&nbsp;</p><p><font face="Courier New" color="#003366" size="4">FirstNonEmptyStringIndexInArray</font></p><pre><font color="#003366">Public Function FirstNonEmptyStringIndexInArray(InputArray As Variant) As Long</font></pre><p><font face="Arial">This function returns the index number of the first entry in an array of 
	strings of an element that is no equal to vbNullString.&nbsp; This is useful 
	when working with arrays of strings that have been sorted in ascending 
	order, which places vbNullString entries at the beginning of the array. In 
	general usages, The InputArray will be sorted in ascending order. For 
	example,<br>
	<br>
	</font><font face="Courier New" color="#003366">Dim A(1 To 4) As String<br>
	Dim R As Long<br>
	A(1) = vbNullString<br>
	A(2) = vbNullString<br>
	A(3) = "A"<br>
	A(4) = "B"<br>
	R = FirstNonEmptyStringIndexInArray(InputArray:=A)<br>
	' R = 3, the first element that is not an empty string<br>
	Debug.Print "FirstNonEmptyStringIndexInArray", CStr(R)<br>
&nbsp;</font></p>
	<p><font face="Courier New" size="4" color="#003366">GetColumn</font></p><pre><font color="#003366">Function GetColumn(Arr As Variant, ResultArr As Variant, ColumnNumber As Long) As Boolean</font></pre><pre><font face="Arial" size="3">This function populates ResultArr with a one-dimensional array that is the column specified by ColumnNumber of the input array Arr.&nbsp; ResultArr must be a
dynamic array. The existing contents of ResultArr are destroyed. </font></pre><pre>&nbsp;</pre><p><font face="Courier New" size="4" color="#003366">GetRow</font></p><pre><font color="#003366">Function GetRow(Arr As Variant, ResultArr As Variant, RowNumber As Long) As Boolean</font></pre><pre><font face="Arial" size="3">This function populates ResultArr with a one-dimensional array that is the row specified by RowNumber of the input array Arr.&nbsp; ResultArr must be a
dynamic array. The existing contents of ResultArr are destroyed. </font></pre><p>&nbsp;</p><p><font face="Courier New" color="#003366" size="4">InsertElementIntoAnArray</font></p><pre><font color="#003366">Public Function InsertElementIntoArray(InputArray As Variant, Index As Long, _
&nbsp;&nbsp;&nbsp; Value As Variant) As Boolean</font></pre><p><font face="Arial">This function inserts the value Value at location 
	Index in InputArray. InputArray must be a single-dimensional dynamic array. 
	It will be resized to make room for the new data element.&nbsp; To insert an 
	element at the end of the array, set Index to UBound(Array)+1. </font></p>
	<p><br>
	<font face="Arial">&nbsp;</font><font face="Courier New" color="#003366" size="4">IsArrayAllDefault</font></p><pre><font color="#003366">Public Function IsArrayAllDefault(InputArray As Variant) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether all the elements in 
	the array have the default value for the particular data type. Depending on 
	the data type of the array, the default value may be vbNullString, 0, Empty, 
	or Nothing.</font></p><p><font face="Arial"><br>
	&nbsp;</font><font face="Courier New" color="#003366" size="4">IsArrayAllNumeric</font></p><pre><font color="#003366">Public Function IsArrayAllNumeric(Arr As Variant, _
&nbsp;&nbsp;&nbsp; Optional AllowNumericStrings As Boolean = False) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether all the elements in 
	the array are numeric. By default Strings are not considered numeric, even 
	if they contain numeric values. To allow numeric strings, set the 
	AllowNumericStrings parameter to True.</font></p><p><font face="Arial"><br>
	</font><font face="Courier New" color="#003366" size="4">IsArrayAllocated</font></p><pre><font color="#003366">Public Function IsArrayAllocated(Arr As Variant) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether the specified array 
	is allocated (not empty).&nbsp; Returns TRUE of the <br>
	array is a static array or a dynamic that has been allocated with a Redim 
	statement.&nbsp; 
	Returns FALSE if the array is a dynamic array that<br>
	has not yet been sized with ReDim or that has been deallocated with the 
	Erase statement. This function is basically the opposite of<br>
	ArrayIsEmpty. For example,</font><font face="Courier New" color="#003366"><br>
	Dim V() As Long<br>
	Dim R As Boolean<br>
	R = IsArrayAllocated(V)&nbsp; ' returns false<br>
	ReDim V(1 To 10)<br>
	R = IsArrayAllocated(V)&nbsp; ' returns true</font></p><p><font face="Arial"><br>
	<br>
	&nbsp;</font><font face="Courier New" color="#003366" size="4">IsArrayDynamic</font></p><pre><font color="#003366">Public Function IsArrayDynamic(ByRef Arr As Variant) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether the specified array 
	is dynamic. Returns TRUE if the array is<br>
	dynamic, or FALSE if the array is static. For example,<br>
	</font><font face="Courier New" color="#003366">Dim DynArray() As Long<br>
	Dim StatArray(1 To 3) As Long<br>
	Dim B As Boolean<br>
	B = IsArrayDynamic(DynArray)&nbsp;&nbsp; ' returns True<br>
	B = IsArrayDynamic(StatArray)&nbsp; ' returns False<br>
	</font><font face="Courier New" color="#003366" size="4"><br>
	<br>
	IsArrayEmpty</font></p><pre><font color="#003366">Public Function IsArrayEmpty(Arr As Variant) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether the specified array 
	is empty (not allocated). This function is basically the opposite of <br>
	IsArrayAllocated.</font><font face="Courier New" color="#003366"><br>
	Dim DynArray() As Long<br>
	Dim R As Boolean<br>
	R = IsArrayEmpty(DynArray)&nbsp; ' returns true<br>
	ReDim V(1 To 10)<br>
	R = IsArrayEmpty(DynArray)&nbsp; ' returns false<br>
	<br>
	<br>
	</font><font face="Courier New" color="#003366" size="4">IsArrayObjects</font></p><pre><font color="#003366">Public Function IsArrayObjects(InputArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional AllowNothing As Boolean = True) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether the specified array 
	contains all Object variables. The objects may be of mixed type. By default, 
	the function allows Nothing objects. That is, an object that is Nothing is 
	still considered an object. To return False if an object is Nothing, set the 
	AllowNothing parameter to False. </font></p>
	<p><font face="Courier New" color="#003366" size="4"><br>IsArraySorted</font></p><pre><font color="#003366">Public Function IsArraySorted(TestArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional Descending As Boolean = False) As Variant</font></pre><p><font face="Arial">This function returns TRUE or FALSE indicating whether the array TestArray is in sorted order (Ascending or Descending, depending on the value of the Descending parameter).&nbsp; It will return NULL if an error occurred. TestArray must be a single-dimensional allocated array.&nbsp; Since sorting is an expensive operation, especially so with large array of Strings or Variants, you can call this function to determine if the array is already sorted before calling upon the <a href="http://www.cpearson.com/excel/QSort.htm">Sort</a> procedures. If this function returns True, you don't need to resort the array. </font></p>
	<p><font color="#003366" face="Courier New"><br>IsNumericDataType</font></p><pre><font color="#003366">Public Function IsNumericDataType(TestVar As Variant) As Boolean</font></pre><p><font face="Arial">This indicates whether a variable is a numeric data type (Long, Integer, 
	Double, Single, Currency, or Decimal). If the input is an array, it tests 
	the first element of the array (note that in an array of variants, 
	subsequent elements may not be numeric). For variable arrays, use&nbsp;
	</font><font color="#003366"><font face="Courier New" size="4">IsVariantArrayNumeric. </font><br>
	&nbsp;</font></p>
	<p><font face="Courier New" color="#003366">IsVariantArrayConsistent</font></p><pre><font color="#003366">Public Function IsVariantArrayConsistent(Arr As Variant) As Boolean</font></pre><p><font face="Arial">This returns TRUE if all the data types in an array of Varaints all have the 
	same data type. Otherwise, it returns False. If the array consists of Object 
	type variables, objects that are Nothing are skipped. The function will 
	return True if all non-object variables are the same type.<br>
&nbsp;</font></p>
	<p><font color="#003366"><font face="Courier New" size="4">IsVariantArrayNumeric</font></font></p><pre><font color="#003366">Public Function IsVariantArrayNumeric(TestArray As Variant) As Boolean</font></pre><p><font face="Arial">This function returns TRUE or FALSE if an array of 
	variants contains all numeric data types. The data types need not be the 
	same. You can have a mix of Integers, Longs, Singles, and Doubles, and 
	Emptys. As long as all the data types are numeric (as determined by the </font>
	<font color="#003366"><font face="Courier New">IsNumericDataType</font>
	</font><font face="Arial">function), the result will be false. The function 
	will return FALSE if the data types or not all numeric, or if the passed-in 
	parameter is not an array or is an unallocated array. This procedure will 
	work with multi-dimensional arrays. <br>
&nbsp;</font></p>
	<p><font face="Courier New" color="#003366">MoveEmptyStringsToEndOfArray</font></p><pre><font color="#003366">Public Function MoveEmptyStringsToEndOfArray(InputArray As Variant) As Boolean</font></pre><p><font face="Arial">This moves empty strings at the beginning of the array to the end of the 
	array, shifting elements of the array to the left. This is useful when 
	dealing with a sorted array of text strings in which empty strings are 
	placed at the beginning of the array. For example:</font></p><p><font face="Courier New" color="#003366">Dim S(1 to 4) As String<br>
	Dim N As Long<br>
	S(1) = vbNullString<br>
	S(2) = vbNullString<br>
	S(3) = "abc"<br>
	S(4) = "def"<br>
	N = MoveEmptyStringsToEndOfArray(S)<br>
	' resulting array:<br>
	For N = LBound(S) To UBound(S)<br>
&nbsp;&nbsp;&nbsp; If S(N) = vbNullString Then <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print CStr(N),"Is vbNullString"<br>
&nbsp;&nbsp;&nbsp; Else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print CStr(N), S(N)<br>
&nbsp;&nbsp;&nbsp; End If<br>
	Next N<br>
&nbsp;</font></p>
	<p><font face="Courier New" color="#003366" size="4">NumberOfDimensions</font></p><pre><font color="#003366">Public Function NumberOfArrayDimensions(Arr As Variant) As Integer</font></pre><p><font face="Arial">This function returns the number of dimensions of the specified array. If 
	the array is a dynamic unallocated array, it returns 0.<br>
	</font><font face="Courier New" color="#003366">Dim V(1 to 10, 1 to 5) As Long<br>
	Dim N As Long<br>
	N = NumberOfDimensions(V)&nbsp; ' returns 2<br>
&nbsp;</font></p>
	<p><font face="Courier New" color="#003366"><font size="4">
	NumElements</font></font></p><pre><font color="#003366">Public Function NumElements(Arr As Variant, Optional Dimension = 1) As Long</font></pre><p><font face="Arial">This function returns the number of elements in 
	the specified dimension of the specified array. It returns 0 if an error 
	condition exists<br>
	(e.g., an unallocated array).</font></p><p><font face="Courier New" color="#003366">Dim V(1 to 10) As Long<br>
	Dim Dimension As Long<br>
	Dim N As Long<br>
	Dimension = 1<br>
	N = NumElements(V, Dimension)&nbsp; ' returns 10<br>
&nbsp;</font></p>
	<p><font face="Courier New" color="#003366" size="4">SetVariableToDefault</font></p><pre><font color="#003366">Public Sub SetVariableToDefault(ByRef Variable As Variant)</font></pre><p><font face="Arial">This procedure sets the Variable argument to the 
	default value appropriate for its data type. This default may be 0, 
	vbNullString, Empty, or Nothing.&nbsp; Note that it cannot reset a 
	User-Defined Type.&nbsp; You can easily set a user defined type back to its 
	default state by declaring a second variable of that type, e.g.,
	</font><font face="Courier New" color="#003366">Dim DefaultType As MyType</font><font face="Arial"> 
	and letting the elements take their default value. Then use
	</font><font face="Courier New" color="#003366">LSet</font><font face="Arial"> 
	to set another instance of your UDT to
	</font><font face="Courier New" color="#003366">DefaultType</font><font face="Arial">:<br>
	<br>
	</font><font face="Courier New" color="#003366">Public Type MyType<br>
&nbsp;&nbsp;&nbsp; X As Long<br>
&nbsp;&nbsp;&nbsp; Y As Long<br>
&nbsp;&nbsp;&nbsp; S As String<br>
	End Type</font></p><p><font face="Courier New" color="#003366">Dim DefaultType As MyType<br>
	Dim DataT As MyType<br>
	DataT.X = 1<br>
	DataT.Y = 2<br>
	DataT.S = "Test"<br>
	' set variables of T back to defaults.<br>
	LSet DataT&nbsp; = DefaultType</font></p><p>&nbsp;</p>
	<p><font face="Courier New" color="#003366"><font size="4">Sorting An Array</font><br>
	</font><font face="Arial">See the <a href="http://www.cpearson.com/excel/QSort.htm">Sorting Arrays With 
	QSort</a> page.<br>
&nbsp;</font></p>
	<p><font face="Courier New" color="#003366">Sorting An Array Of Objects</font><font face="Arial"><br>
	See the <a href="http://www.cpearson.com/excel/_vti_cnf/SortingArraysOfObjects.htm">Sorting Arrays Of 
	Objects</a> page.<br>
&nbsp;</font></p><p><font face="Courier New" color="#003366"><font size="4">SwapArrayRows</font></font><font face="Arial" size="4"> and </font><font face="Courier New" color="#003366"><font size="4">SwapArrayColumns</font></font></p><pre><font color="#003366">&nbsp;&nbsp;&nbsp; Function SwapArrayColumns(Arr As Variant, Col1 As Long, Col2 As Long) As Variant</font></pre><pre><font color="#003366">&nbsp;&nbsp;&nbsp; Function SwapArrayRows(Arr As Variant, Row1 As Long, Row2 As Long) As Variant</font></pre><p><font face="Arial">These functions take in an array Arr and return a copy of the array with the specified rows or columns swapped.</font></p><p>&nbsp;</p><p><font face="Courier New" size="4" color="#003366">
	ResetVariantArrayToDefaults</font></p><pre><font color="#003366">Public Function ResetVariantArrayToDefaults(InputArray As Variant) As Boolean</font></pre><p><font face="Arial">This function resets all the elements of an array of 
	Variants to the appropriate default value (0, vbNullString, Empty, or 
	Nothing). The array may consist of several different data types (e.g., some 
	Longs, some Objects, some Strings, etc) and each element will be reset to 
	the appropriate default value.
	</font></p>
	<p>&nbsp;</p>
	<p><font size="4" face="Courier New" color="#003366">ReverseArrayInPlace</font></p><pre><font color="#003366">Public Function ReverseArrayInPlace(InputArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional NoAlerts As Boolean = False) As Boolean</font></pre><p><font face="Arial">This sub reverses the order of an array. It does 
	the reversal in place. That is, the array variable in the calling procedure 
	is reversed. The input array must be 
	a single-dimensional array. The function returns True if the array was 
	successfully reversed, or False if an error occurred.<br>
	</font><font face="Courier New" color="#003366">Dim V(1 to 10) As String<br>
	Dim B As Boolean<br>
	' load V with some values<br>
	<font size="4">B = ReverseArrayInPlace(V)</font></font></p><p><font face="Courier New" color="#003366"><font size="4"><br>
	ReverseArrayOfObjectsInPlace</font></font></p><pre><font color="#003366">Public Function ReverseArrayOfObjectsInPlace(InputArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional NoAlerts As Boolean = False) As Boolean</font></pre><p><font face="Arial">This sub reverses the order of an array. It does 
	the reversal in place. That is, the array variable in the calling procedure 
	is reversed. The function returns True or False indicating whether the array 
	was successfully reversed.&nbsp; An error will occur if an array element is 
	not an object (Nothing objects are allowed).<br>
	</font><font face="Courier New" color="#003366">Dim V(1 to 10) As Object<br>
	Dim B As Boolean<br>
	' load V with some objects<br>
	<font size="4">B = ReverseArrayOfObjectsInPlace(V)</font></font></p><p><br>
	<font face="Courier New" size="4" color="#003366">SetObjectArrayToNothing</font></p><pre><font color="#003366">Public Function SetObjectArrayToNothing(InputArray As Variant) As Boolean</font></pre><p><font face="Arial">This function sets all the elements of the 
	specified array to Nothing. The InputArray must be declared as an array of 
	objects, either a specific object type or a generic Object, or as Variants.&nbsp; 
	An error occurs if an element in the array is not an object or Nothing. The 
	array is not resized -- it remains the same size. Use this function instead 
	of Erase when working with arrays of variants because Erase will set each 
	element in the array to Empty, not Nothing and the element will cease to be 
	considered an Object.
	</font></p>
	<p>
	<font face="Courier New" size="4" color="#003366">SetVariableToDefault</font></p><pre><font color="#003366">Public Sub SetVariableToDefault(ByRef Variable As Variant)</font></pre><p><font face="Arial">This procedure sets Variable to the appropriate 
	default value for its data type. This default value will be 0, vbNullString, 
	Empty, or Nothing depending on the data type of Variable.</font></p><p><font face="Courier New" size="4" color="#003366">TransposeArray</font></p><pre><font color="#003366">Public Function TransposeArray(InputArr As Variant, OutputArr As Variant) As Boolean</font></pre><p><font face="Arial">This procedure transposes a two dimensional array, 
	creating a result array with the number of rows equal to the number of 
	columns in the input array, and the number of columns equal to the number of 
	rows in the input array. The LBounds and UBounds are preserved.&nbsp; The 
	OutputArr must be a dynamic array. It will be Erased and Redim'd, so any 
	existing content will be destroyed. </font></p>
	<p><font face="Courier New" color="#003366" size="4">VectorsToArray</font></p><pre><font color="#003366">Public Function VectorsToArray(Arr As Variant, ParamArray Vectors()) As Boolean</font></pre><p><font face="Arial">This procedure takes any number of single dimensional 
	arrays and combines them into a single two-dimensional array. The input 
	arrays are in the ParamArray Vectors() parameter, and the array into which 
	they will be placed is specified by Arr. Arr MUST be a dynamic array, and 
	its data type must be compatible with all the elements in all the vectors. 
	Arr is Erased and then Redim'd, so any existing content is destroyed.&nbsp; 
	Each array in Vectors must be a single-dimensional allocated array. If a 
	Vector is an unallocated array, the function will exit with a result of 
	False.&nbsp; </font></p>
	<p><font face="Arial">Each array in Vectors is one row of Arr. The number of 
	rows in Arr is the number of Vectors passed in. Each row of Arr is one 
	vector. The number of columns is the <i>maximum</i> of the sizes of the 
	Vectors. Since Arr is Erased, unused elements in Arr remain at the default 
	value ofr the data type of Arr (the default value is either 0, vbNullString, 
	or Empty, depending on how Arr was allocated).&nbsp; The elements of each 
	vector must be simple data types. Objects, arrays, and user-defined types 
	are not allowed. Both the rows and columns of Arr are 0-based, regardless of 
	the original setting of Arr, the LBounds of each vector, and the Option Base 
	statement.&nbsp; The vectors may be of different sizes and have different 
	LBounds.</font></p><p>&nbsp;</p>
	<p>&nbsp;</p>
	<p><font face="Arial" size="5">The VBA Code For The Functions<br>
	</font><font face="Arial">You can download a
	<a href="http://www.cpearson.com/Zips/modArraySupport.zip">bas module file containing these 
	function here</a> or a <a href="http://www.cpearson.com/Zips/ArraySupport.zip">complete workbook 
	containing the functions and demonstration procedures here</a>. Please read 
	the comments within each procedure. They include important information about 
	how the function works under various conditions. Many of these functions 
	call upon one another, so it is recommended that you include the entire 
	module within your project.</font></p><pre><font color="#003366">Option Explicit
Option Compare Text
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' modArraySupport
' By Chip Pearson, chip@cpearson.com, www.cpearson.com
'
' This module contains procedures that provide information about and manipulate
' VB/VBA arrays.
'
' For details on these functions, see www.cpearson.com/excel/VBAArrays.htm
'
' This module contains the following functions:
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ChangeBoundsOfArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CompareArrays
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConcatenateArrays
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyArraySubSetToArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyNonNothingObjectsToArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTypeOfArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteArrayElement
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FirstNonEmptyStringIndexInArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InsertElementIntoArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllDefault
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllocated
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayDynamic
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayEmpty
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayObjects
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveEmptyStringsToEndOfArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumberOfArrayDimensions
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumElements
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResetVariantArrayToDefaults
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReverseArrayInPlace
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReverseArrayOfObjectsInPlace
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetObjectArrayToNothing
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetVariableToDefault
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TransposeArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VectorsToArray
'
' Function documentation is in each function.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''
' Error Number Constants
'''''''''''''''''''''''''''
Public Const C_ERR_NO_ERROR = 0&amp;
Public Const C_ERR_SUBSCRIPT_OUT_OF_RANGE = 9&amp;
Public Const C_ERR_ARRAY_IS_FIXED_OR_LOCKED = 10&amp;
</font></pre><pre><font color="#003366">Public Function ChangeBoundsOfArray(InputArr As Variant, _
&nbsp;&nbsp;&nbsp; NewLowerBound As Long, NewUpperBound) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ChangeBoundsOfArray
' This function changes the lower and upper bounds of the specified
' array. InputArr MUST be a single-dimensional, dynamic, allocated array.
' If the new size of the array (NewUpperBound - NewLowerBound + 1)
' is greater than the original array, the unused elements on
' right side of the new array are the default values for the data type
' of the array. If the new size is less than the original size,
' only the first (left-most) N elements are included in the new array.
' The elements of the array may be simple variables (Strings, Longs, etc)
' Objects, or Arrays. User-Defined Types are not supported.
'
' The function returns True if successful, False otherwise.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim TempArr() As Variant
Dim InNdx As Long
Dim OutNdx As Long
Dim TempNdx As Long
Dim FirstIsObject As Boolean

''''''''''''''''''''''''''''''''''''
' Ensure we have an array.
''''''''''''''''''''''''''''''''''''
If IsArray(InputArr) = False Then
&nbsp;&nbsp;&nbsp; ChangeBoundsOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''''''
' Ensure the array is dynamic.
''''''''''''''''''''''''''''''''''''
If IsArrayDynamic(InputArr) = False Then
&nbsp;&nbsp;&nbsp; ChangeBoundsOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''''''
' Ensure the array is allocated.
''''''''''''''''''''''''''''''''''''
If IsArrayAllocated(InputArr) = False Then
&nbsp;&nbsp;&nbsp; ChangeBoundsOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''''''''''
' Ensure the NewLowerBound &gt; NewUpperBound.
'''''''''''''''''''''''''''''''''''''''''''
If NewLowerBound &gt; NewUpperBound Then
&nbsp;&nbsp;&nbsp; ChangeBoundsOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''''''''''''''
' Ensure Arr is a single dimensional array.
'''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(InputArr) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; ChangeBoundsOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''''''''
' We need to save the IsObject status of the first
' element of the InputArr to properly handle
' the Empty variables is we are making the array
' larger than it was before.
'''''''''''''''''''''''''''''''''''''''''''''''''''
FirstIsObject = IsObject(InputArr(LBound(InputArr)))


''''''''''''''''''''''''''''''''''''''''''''
' Resize TempArr and save the values in
' InputArr in TempArr. TempArr will have
' an LBound of 1 and a UBound of the size
' of (NewUpperBound - NewLowerBound +1)
'''''''''''''''''''''''''''''''''''''''''''
ReDim TempArr(1 To (NewUpperBound - NewLowerBound + 1))
'''''''''''''''''''''''''''''''''''''''''''
' Load up TempArr
'''''''''''''''''''''''''''''''''''''''''''
TempNdx = 0
For InNdx = LBound(InputArr) To UBound(InputArr)
&nbsp;&nbsp;&nbsp; TempNdx = TempNdx + 1
&nbsp;&nbsp;&nbsp; If TempNdx &gt; UBound(TempArr) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit For
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; If (IsObject(InputArr(InNdx)) = True) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If InputArr(InNdx) Is Nothing Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set TempArr(TempNdx) = Nothing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set TempArr(TempNdx) = InputArr(InNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TempArr(TempNdx) = InputArr(InNdx)
&nbsp;&nbsp;&nbsp; End If
Next InNdx

''''''''''''''''''''''''''''''''''''
' Now, Erase InputArr, resize it to the
' new bounds, and load up the values from
' TempArr to the new InputArr.
''''''''''''''''''''''''''''''''''''
Erase InputArr
ReDim InputArr(NewLowerBound To NewUpperBound)
OutNdx = LBound(InputArr)
For TempNdx = LBound(TempArr) To UBound(TempArr)
&nbsp;&nbsp;&nbsp; If OutNdx &lt;= UBound(InputArr) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(TempArr(TempNdx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set InputArr(OutNdx) = TempArr(TempNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If FirstIsObject = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsEmpty(TempArr(TempNdx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set InputArr(OutNdx) = Nothing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set InputArr(OutNdx) = TempArr(TempNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArr(OutNdx) = TempArr(TempNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit For
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; OutNdx = OutNdx + 1
Next TempNdx

'''''''''''''''''''''''''''''
' Success -- Return True
'''''''''''''''''''''''''''''
ChangeBoundsOfArray = True

End Function</font>
</pre><pre><font color="#003366">

Public Function CompareArrays(Array1 As Variant, Array2 As Variant, _
&nbsp;&nbsp;&nbsp; ResultArray As Variant, Optional CompareMode As VbCompareMethod = vbTextCompare) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' CompareArrays
' This function compares two arrays, Array1 and Array2, element by element, and puts the results of
' the comparisons in ResultArray. Each element of ResultArray will be -1, 0, or +1. A -1 indicates that
' the element in Array1 was less than the corresponding element in Array2. A 0 indicates that the
' elements are equal, and +1 indicates that the element in Array1 is greater than Array2. Both
' Array1 and Array2 must be allocated single-dimensional arrays, and ResultArray must be dynamic array
' of a numeric data type (typically Longs). Array1 and Array2 must contain the same number of elements,
' and have the same lower bound. The LBound of ResultArray will be the same as the data arrays.
'
' An error will occur if Array1 or Array2 contains an Object or User Defined Type.
'
' When comparing elements, the procedure does the following:
' If both elements are numeric data types, they are compared arithmetically.

' If one element is a numeric data type and the other is a string and that string is numeric,
' then both elements are converted to Doubles and compared arithmetically. If the string is not
' numeric, both elements are converted to strings and compared using StrComp, with the
' compare mode set by CompareMode.
'
' If both elements are numeric strings, they are converted to Doubles and compared arithmetically.
'
' If either element is not a numeric string, the elements are converted and compared with StrComp.
'
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Ndx1 As Long
Dim Ndx2 As Long
Dim ResNdx As Long
Dim S1 As String
Dim S2 As String
Dim D1 As Double
Dim D2 As Double
Dim Done As Boolean
Dim Compare As VbCompareMethod
Dim LB As Long

''''''''''''''''''''''''''''''''''''
' Set the default return value.
''''''''''''''''''''''''''''''''''''
CompareArrays = False

''''''''''''''''''''''''''''''''''''
' Ensure we have a Compare mode
' value.
''''''''''''''''''''''''''''''''''''
If CompareMode = vbBinaryCompare Then
&nbsp;&nbsp;&nbsp; Compare = vbBinaryCompare
Else
&nbsp;&nbsp;&nbsp; Compare = vbTextCompare
End If


''''''''''''''''''''''''''''''''''''
' Ensure we have arrays.
''''''''''''''''''''''''''''''''''''
If IsArray(Array1) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If IsArray(Array2) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If IsArray(ResultArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''
' Ensure ResultArray is dynamic
'''''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr:=ResultArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''
' Ensure the arrays are single-dimensional.
''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=Array1) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If NumberOfArrayDimensions(Arr:=Array2) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If NumberOfArrayDimensions(Arr:=Array1) &gt; 1 Then 'allow 0 indicating non-allocated array
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''
' Ensure the LBounds are the same
''''''''''''''''''''''''''''''''''''''''''
If LBound(Array1) &lt;&gt; LBound(Array2) Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;

''''''''''''''''''''''''''''''''''''''''''
' Ensure the arrays are the same size.
''''''''''''''''''''''''''''''''''''''''''
If (UBound(Array1) - LBound(Array1)) &lt;&gt; (UBound(Array2) - LBound(Array2)) Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''
' Redim ResultArray to the numbr of elements
' in Array1.
''''''''''''''''''''''''''''''''''''''''''''''
ReDim ResultArray(LBound(Array1) To UBound(Array1))

Ndx1 = LBound(Array1)
Ndx2 = LBound(Array2)

''''''''''''''''''''''''''''''''''''''''''''''
' Scan each array to see if it contains objects
' or User-Defined Types. If found, exit with
' False.
''''''''''''''''''''''''''''''''''''''''''''''
For Ndx1 = LBound(Array1) To UBound(Array1)
&nbsp;&nbsp;&nbsp; If IsObject(Array1(Ndx1)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; If VarType(Array1(Ndx1)) &gt;= vbArray Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; If VarType(Array1(Ndx1)) = vbUserDefinedType Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
Next Ndx1

For Ndx1 = LBound(Array2) To UBound(Array2)
&nbsp;&nbsp;&nbsp; If IsObject(Array2(Ndx1)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; If VarType(Array2(Ndx1)) &gt;= vbArray Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; If VarType(Array2(Ndx1)) = vbUserDefinedType Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
Next Ndx1

Ndx1 = LBound(Array1)
Ndx2 = Ndx1
ResNdx = LBound(ResultArray)
Done = False
Do Until Done = True
''''''''''''''''''''''''''''''''''''
' Loop until we reach the end of
' the array.
''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If IsNumeric(Array1(Ndx1)) = True And IsNumeric(Array2(Ndx2)) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D1 = CDbl(Array1(Ndx1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D2 = CDbl(Array2(Ndx2))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If D1 = D2 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(ResNdx) = 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ElseIf D1 &lt; D2 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(ResNdx) = -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(ResNdx) = 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S1 = CStr(Array1(Ndx1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S2 = CStr(Array2(Ndx1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(ResNdx) = StrComp(S1, S2, Compare)
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ResNdx = ResNdx + 1
&nbsp;&nbsp;&nbsp; Ndx1 = Ndx1 + 1
&nbsp;&nbsp;&nbsp; Ndx2 = Ndx2 + 1
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If Ndx1 is greater than UBound(Array1)
&nbsp;&nbsp;&nbsp; ' we've hit the end of the arrays.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If Ndx1 &gt; UBound(Array1) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Done = True
&nbsp;&nbsp;&nbsp; End If
Loop

CompareArrays = True
End Function



Public Function ConcatenateArrays(ResultArray As Variant, ArrayToAppend As Variant, _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optional NoCompatabilityCheck As Boolean = False) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ConcatenateArrays
' This function appends ArrayToAppend to the end of ResultArray, increasing the size of ResultArray
' as needed. ResultArray must be a dynamic array, but it need not be allocated. ArrayToAppend
' may be either static or dynamic, and if dynamic it may be unallocted. If ArrayToAppend is
' unallocated, ResultArray is left unchanged.
'
' The data types of ResultArray and ArrayToAppend must be either the same data type or
' compatible numeric types. A compatible numeric type is a type that will not cause a loss of
' precision or cause an overflow. For example, ReturnArray may be Longs, and ArrayToAppend amy
' by Longs or Integers, but not Single or Doubles because information might be lost when
' converting from Double to Long (the decimal portion would be lost). To skip the compatability
' check and allow any variable type in ResultArray and ArrayToAppend, set the NoCompatabilityCheck
' parameter to True. If you do this, be aware that you may loose precision and you may will
' get an overflow error which will cause a result of 0 in that element of ResultArra.
'
' Both ReaultArray and ArrayToAppend must be one-dimensional arrays.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim VTypeResult As VbVarType
Dim Ndx As Long
Dim Res As Long
Dim NumElementsToAdd As Long
Dim AppendNdx As Long
Dim VTypeAppend As VbVarType
Dim ResultLB As Long
Dim ResultUB As Long
Dim ResultWasAllocated As Boolean

'''''''''''''''''''''''''''''''''
' Set the default result.
''''''''''''''''''''''''''''''''
ConcatenateArrays = False

'''''''''''''''''''''''''''''''''
' Ensure ResultArray is an array.
'''''''''''''''''''''''''''''''''
If IsArray(ResultArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''''
' Ensure ArrayToAppend is an array.
''''''''''''''''''''''''''''''''''
If IsArray(ArrayToAppend) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure both arrays are single
' dimensional.
''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(ResultArray) &gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If NumberOfArrayDimensions(ArrayToAppend) &gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''
' Ensure ResultArray is dynamic.
'''''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr:=ResultArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''
' Ensure ArrayToAppend is allocated.
' If ArrayToAppend is not allocated,
' we have nothing to append, so
' exit with a True result.
''''''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=ArrayToAppend) = False Then
&nbsp;&nbsp;&nbsp; ConcatenateArrays = True
&nbsp;&nbsp;&nbsp; Exit Function
End If


If NoCompatabilityCheck = False Then
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Ensure the array are compatible
&nbsp;&nbsp;&nbsp; ' data types.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If AreDataTypesCompatible(DestVar:=ResultArray, SourceVar:=ArrayToAppend) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' The arrays are not compatible data types.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If one array is an array of
&nbsp;&nbsp;&nbsp; ' objects, ensure the other contains
&nbsp;&nbsp;&nbsp; ' all objects (or Nothing)
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If VarType(ResultArray) - vbArray = vbObject Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsArrayAllocated(ArrayToAppend) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For Ndx = LBound(ArrayToAppend) To UBound(ArrayToAppend)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(ArrayToAppend(Ndx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next Ndx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
End If
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
'''''''''''''''''''''''''''''''''''''''
' Get the number of elements in
' ArrrayToAppend
'''''''''''''''''''''''''''''''''''''''
NumElementsToAdd = UBound(ArrayToAppend) - LBound(ArrayToAppend) + 1
''''''''''''''''''''''''''''''''''''''''
' Get the bounds for resizing the
' ResultArray. If ResultArray is allocated
' use the LBound and UBound+1. If
' ResultArray is not allocated, use
' the LBound of ArrayToAppend for both
' the LBound and UBound of ResultArray.
''''''''''''''''''''''''''''''''''''''''

If IsArrayAllocated(Arr:=ResultArray) = True Then
&nbsp;&nbsp;&nbsp; ResultLB = LBound(ResultArray)
&nbsp;&nbsp;&nbsp; ResultUB = UBound(ResultArray)
&nbsp;&nbsp;&nbsp; ResultWasAllocated = True
&nbsp;&nbsp;&nbsp; ReDim Preserve ResultArray(ResultLB To ResultUB + NumElementsToAdd)
Else
&nbsp;&nbsp;&nbsp; ResultUB = UBound(ArrayToAppend)
&nbsp;&nbsp;&nbsp; ResultWasAllocated = False
&nbsp;&nbsp;&nbsp; ReDim ResultArray(LBound(ArrayToAppend) To UBound(ArrayToAppend))
End If

''''''''''''''''''''''''''''''''''''''''
' Copy the data from ArrayToAppend to
' ResultArray.
''''''''''''''''''''''''''''''''''''''''
If ResultWasAllocated = True Then
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If ResultArray was allocated, we
&nbsp;&nbsp;&nbsp; ' have to put the data from ArrayToAppend
&nbsp;&nbsp;&nbsp; ' at the end of the ResultArray.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; AppendNdx = LBound(ArrayToAppend)
&nbsp;&nbsp;&nbsp; For Ndx = ResultUB + 1 To UBound(ResultArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(ArrayToAppend(AppendNdx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set ResultArray(Ndx) = ArrayToAppend(AppendNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(Ndx) = ArrayToAppend(AppendNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AppendNdx = AppendNdx + 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If AppendNdx &gt; UBound(ArrayToAppend) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit For
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Next Ndx
Else
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If ResultArray was not allocated, we simply
&nbsp;&nbsp;&nbsp; ' copy element by element from ArrayToAppend
&nbsp;&nbsp;&nbsp; ' to ResultArray.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For Ndx = LBound(ResultArray) To UBound(ResultArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(ArrayToAppend(Ndx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set ResultArray(Ndx) = ArrayToAppend(Ndx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(Ndx) = ArrayToAppend(Ndx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Next Ndx

End If
'''''''''''''''''''''''
' Success. Return True.
'''''''''''''''''''''''
ConcatenateArrays = True

End Function

Public Function CopyArray(DestinationArray As Variant, SourceArray As Variant, _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optional NoCompatabilityCheck As Boolean = False) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' CopyArray
' This function copies the contents of SourceArray to the DestinationaArray. Both SourceArray
' and DestinationArray may be either static or dynamic and either or both may be unallocated.
'
' If DestinationArray is dynamic, it is resized to match SourceArray. The LBound and UBound
' of DestinationArray will be the same as SourceArray, and all elements of SourceArray will
' be copied to DestinationArray.
'
' If DestinationArray is static and has more elements than SourceArray, all of SourceArray
' is copied to DestinationArray and the right-most elements of DestinationArray are left
' intact.
'
' If DestinationArray is static and has fewer elements that SourceArray, only the left-most
' elements of SourceArray are copied to fill out DestinationArray.
'
' If SourceArray is an unallocated array, DestinationArray remains unchanged and the procedure
' terminates.
'
' If both SourceArray and DestinationArray are unallocated, no changes are made to either array
' and the procedure terminates.
'
' SourceArray may contain any type of data, including Objects and Objects that are Nothing
' (the procedure does not support arrays of User Defined Types since these cannot be coerced
' to Variants -- use classes instead of types).
'
' The function tests to ensure that the data types of the arrays are the same or are compatible.
' See the function AreDataTypesCompatible for information about compatible data types. To skip
' this compability checking, set the NoCompatabilityCheck parameter to True. Note that you may
' lose information during data conversion (e.g., losing decimal places when converting a Double
' to a Long) or you may get an overflow (storing a Long in an Integer) which will result in that
' element in DestinationArray having a value of 0.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim VTypeSource As VbVarType
Dim VTypeDest As VbVarType
Dim SNdx As Long
Dim DNdx As Long


'''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''
CopyArray = False

''''''''''''''''''''''''''''''''''
' Ensure both DestinationArray and
' SourceArray are arrays.
''''''''''''''''''''''''''''''''''
If IsArray(DestinationArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If IsArray(SourceArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''
' Ensure DestinationArray and
' SourceArray are single-dimensional.
' 0 indicates an unallocated array,
' which is allowed.
'''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=SourceArray) &gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If NumberOfArrayDimensions(Arr:=DestinationArray) &gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''
' If SourceArray is not allocated,
' leave DestinationArray intact and
' return a result of True.
''''''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=SourceArray) = False Then
&nbsp;&nbsp;&nbsp; CopyArray = True
&nbsp;&nbsp;&nbsp; Exit Function
End If

If NoCompatabilityCheck = False Then
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Ensure both arrays are the same
&nbsp;&nbsp;&nbsp; ' type or compatible data types. See
&nbsp;&nbsp;&nbsp; ' the function AreDataTypesCompatible
&nbsp;&nbsp;&nbsp; ' for information about compatible
&nbsp;&nbsp;&nbsp; ' types.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If AreDataTypesCompatible(DestVar:=DestinationArray, SourceVar:=SourceArray) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyArray = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If one array is an array of
&nbsp;&nbsp;&nbsp; ' objects, ensure the other contains
&nbsp;&nbsp;&nbsp; ' all objects (or Nothing)
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If VarType(DestinationArray) - vbArray = vbObject Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsArrayAllocated(SourceArray) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For SNdx = LBound(SourceArray) To UBound(SourceArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(SourceArray(SNdx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next SNdx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
End If

If IsArrayAllocated(Arr:=DestinationArray) = True Then
&nbsp;&nbsp;&nbsp; If IsArrayAllocated(Arr:=SourceArray) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If both arrays are allocated, copy from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' SourceArray to DestinationArray. If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' SourceArray is smaller that DesetinationArray,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' the right-most elements of DestinationArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' are left unchanged. If SourceArray is larger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' than DestinationArray, the right most elements
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' of SourceArray are not copied.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DNdx = LBound(DestinationArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Error Resume Next
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For SNdx = LBound(SourceArray) To UBound(SourceArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(SourceArray(SNdx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set DestinationArray(DNdx) = SourceArray(DNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestinationArray(DNdx) = SourceArray(DNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DNdx = DNdx + 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If DNdx &gt; UBound(DestinationArray) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit For
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next SNdx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Error GoTo 0
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If SourceArray is not allocated, so we have
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' nothing to copy. Exit with a result
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' of True. Leave DestinationArray intact.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyArray = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Else
&nbsp;&nbsp;&nbsp; If IsArrayAllocated(Arr:=SourceArray) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If Destination array is not allocated and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' SourceArray is allocated, Redim DestinationArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' to the same size as SourceArray and copy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' the elements from SourceArray to DestinationArray.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Error Resume Next
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim DestinationArray(LBound(SourceArray) To UBound(SourceArray))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For SNdx = LBound(SourceArray) To UBound(SourceArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(SourceArray(SNdx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set DestinationArray(SNdx) = SourceArray(SNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DestinationArray(SNdx) = SourceArray(SNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next SNdx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Error GoTo 0
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If both SourceArray and DestinationArray are
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' unallocated, we have nothing to copy (this condition
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' is actually detected above, but included here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' for consistancy), so get out with a result of True.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CopyArray = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
End If

'''''''''''''''''''''''
' Success. Return True.
'''''''''''''''''''''''
CopyArray = True

End Function



Public Function CopyArraySubSetToArray(InputArray As Variant, ResultArray As Variant, _
&nbsp;&nbsp;&nbsp; FirstElementToCopy As Long, LastElementToCopy As Long, DestinationElement As Long) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' CopyArraySubSetToArray
' This function copies elements of InputArray to ResultArray. It takes the elements
' from FirstElementToCopy to LastElementToCopy (inclusive) from InputArray and
' copies them to ResultArray, starting at DestinationElement. Existing data in
' ResultArray will be overwrittten. If ResultArray is a dynamic array, it will
' be resized if needed. If ResultArray is a static array and it is not large
' enough to copy all the elements, no elements are copied and the function
' returns False.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;
Dim SrcNdx As Long
Dim DestNdx As Long
Dim NumElementsToCopy As Long

'''''''''''''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''''''''''''
CopyArraySubSetToArray = False

''''''''''''''''''''''''''''''''''''''''''
' Ensure InputArray and ResultArray are
' arrays.
''''''''''''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If IsArray(ResultArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''''''''''
' Ensure InputArray is single dimensional.
'''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=InputArray) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''''''''''
' Ensure ResultArray is unallocated or
' single dimensional.
'''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=ResultArray) &gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''
' Ensure the bounds and indexes are valid.
''''''''''''''''''''''''''''''''''''''''''''
If FirstElementToCopy &lt; LBound(InputArray) Then
&nbsp;&nbsp;&nbsp; Exit Function
End If
If LastElementToCopy &gt; UBound(InputArray) Then
&nbsp;&nbsp; Exit Function
End If
If FirstElementToCopy &gt; LastElementToCopy Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''
' Calc the number of elements we'll copy
' from InputArray to ResultArray.
'''''''''''''''''''''''''''''''''''''''''
NumElementsToCopy = LastElementToCopy - FirstElementToCopy + 1

If IsArrayDynamic(Arr:=ResultArray) = False Then
&nbsp;&nbsp;&nbsp; If (DestinationElement + NumElementsToCopy - 1) &gt; UBound(ResultArray) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' ResultArray is static and can't be resized.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' There is not enough room in the array to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' copy all the data.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
Else
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' ResultArray is dynamic and can be resized.
&nbsp;&nbsp;&nbsp; ' Test whether we need to resize the array,
&nbsp;&nbsp;&nbsp; ' and resize it if required.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If IsArrayEmpty(Arr:=ResultArray) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' ResultArray is unallocated. Resize it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' to DestinationElement + NumElementsToCopy - 1.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This provides empty elements to the left
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' of the DestinationElement and room to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' copy NumElementsToCopy.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim ResultArray(1 To DestinationElement + NumElementsToCopy - 1)
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' ResultArray is allocated. If there isn't room
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' enough in ResultArray to hold NumElementsToCopy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' starting at DestinationElement, we need to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' resize the array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If (DestinationElement + NumElementsToCopy - 1) &gt; UBound(ResultArray) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If DestinationElement + NumElementsToCopy &gt; UBound(ResultArray) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Resize the ResultArray.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NumElementsToCopy + DestinationElement &gt; UBound(ResultArray) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim Preserve ResultArray(LBound(ResultArray) To UBound(ResultArray) + DestinationElement - 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim Preserve ResultArray(LBound(ResultArray) To UBound(ResultArray) + NumElementsToCopy)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Resize the array to hold NumElementsToCopy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' starting at DestinationElement.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim Preserve ResultArray(LBound(ResultArray) To UBound(ResultArray) + NumElementsToCopy - DestinationElement + 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' The ResultArray is large enough to hold
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' NumberOfElementToCopy starting at DestinationElement.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' No need to resize the array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
End If


'''''''''''''''''''''''''''''''''''''''''''''''''''
' Copy the elements from InputArray to ResultArray
' Note that there is no type compatibility checking
' when copying the elements.
'''''''''''''''''''''''''''''''''''''''''''''''''''
DestNdx = DestinationElement
For SrcNdx = FirstElementToCopy To LastElementToCopy
&nbsp;&nbsp;&nbsp; If IsObject(InputArray(SrcNdx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set ResultArray(DestNdx) = InputArray(DestNdx)
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Error Resume Next
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultArray(DestNdx) = InputArray(SrcNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; On Error GoTo 0
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; DestNdx = DestNdx + 1
Next SrcNdx
&nbsp;&nbsp;&nbsp;
CopyArraySubSetToArray = True
&nbsp;&nbsp;&nbsp;
End Function



Public Function CopyNonNothingObjectsToArray(ByRef SourceArray As Variant, _
&nbsp;&nbsp;&nbsp; ByRef ResultArray As Variant, Optional NoAlerts As Boolean = False) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' CopyNonNothingObjectsToArray
' This function copies all objects that are not Nothing from SourceArray
' to ResultArray. ResultArray MUST be a dynamic array of type Object or Variant.
' E.g.,
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim ResultArray() As Object ' Or
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim ResultArray() as Variant
'
' ResultArray will be Erased and then resized to hold the non-Nothing elements
' from SourceArray. The LBound of ResultArray will be the same as the LBound
' of SourceArray, regardless of what its LBound was prior to calling this
' procedure.
'
' This function returns True if the operation was successful or False if an
' an error occurs. If an error occurs, a message box is displayed indicating
' the error. To suppress the message boxes, set the NoAlerts parameter to
' True.
'
' This function uses the following procedures. They are declared as Private
' procedures at the end of this module.
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayDynamic
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayEmpty
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumberOfArrayDimensions
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim ResNdx As Long
Dim InNdx&nbsp; As Long

'''''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''''
CopyNonNothingObjectsToArray = False

'''''''''''''''''''''''''''''''''''
' Ensure SourceArray is an array.
'''''''''''''''''''''''''''''''''''
If IsArray(SourceArray) = False Then
&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "SourceArray is not an array."
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''
' Ensure SourceArray is a single
' dimensional array.
'''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(Arr:=SourceArray)
&nbsp;&nbsp;&nbsp; Case 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Unallocated dynamic array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Not Allowed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "SourceArray is an unallocated array."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Case 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Single-dimensional array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This is OK.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Multi-dimensional array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This is not allowed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "SourceArray is a multi-dimensional array. This is not allowed."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select
'''''''''''''''''''''''''''''''''''
' Ensure ResultArray is an array.
'''''''''''''''''''''''''''''''''''
If IsArray(ResultArray) = False Then
&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "ResultArray is not an array."
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''
' Ensure ResultArray is an dynamic.
'''''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr:=ResultArray) = False Then
&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "ResultArray is not a dynamic array."
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''
' Ensure ResultArray is a single
' dimensional array.
'''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(Arr:=ResultArray)
&nbsp;&nbsp;&nbsp; Case 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Unallocated dynamic array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This is OK.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Case 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Single-dimensional array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This is OK.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Multi-dimensional array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This is not allowed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "SourceArray is a multi-dimensional array. This is not allowed."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select

'''''''''''''''''''''''''''''''''
' Ensure that all the elements of
' SourceArray are in fact objects.
'''''''''''''''''''''''''''''''''
For InNdx = LBound(SourceArray) To UBound(SourceArray)
&nbsp;&nbsp;&nbsp; If IsObject(SourceArray(InNdx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "Element " &amp; CStr(InNdx) &amp; " of SourceArray is not an object."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
Next InNdx

''''''''''''''''''''''''''''''
' Erase the ResultArray. Since
' ResultArray is dynamic, this
' will relase the memory used
' by ResultArray and return
' the array to an unallocated
' state.
''''''''''''''''''''''''''''''
Erase ResultArray
''''''''''''''''''''''''''''''
' Now, size ResultArray to the
' size of SourceArray. After
' moving all the non-Nothing
' elements, we'll do another
' resize to get ResultArray
' to the used size. This method
' allows us to avoid Redim
' Preserve for every element.
'''''''''''''''''''''''''''''
ReDim ResultArray(LBound(SourceArray) To UBound(SourceArray))

ResNdx = LBound(SourceArray)
For InNdx = LBound(SourceArray) To UBound(SourceArray)
&nbsp;&nbsp;&nbsp; If Not SourceArray(InNdx) Is Nothing Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set ResultArray(ResNdx) = SourceArray(InNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResNdx = ResNdx + 1
&nbsp;&nbsp;&nbsp; End If
Next InNdx
''''''''''''''''''''''''''''''''''''''''''
' Now that we've copied all the
' non-Nothing elements from SourceArray
' to ResultArray, we call Redim Preserve
' to resize the ResultArray to the size
' actually used. Test ResNdx to see
' if we actually copied any elements.
''''''''''''''''''''''''''''''''''''''''''
If ResNdx &gt; LBound(SourceArray) Then
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If ResNdx &gt; LBound(SourceArray) then
&nbsp;&nbsp;&nbsp; ' we copied at least one element out of
&nbsp;&nbsp;&nbsp; ' SourceArray.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ReDim Preserve ResultArray(LBound(ResultArray) To ResNdx - 1)
Else
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Otherwise, we didn't copy any elements
&nbsp;&nbsp;&nbsp; ' from SourceArray (all elements in SourceArray
&nbsp;&nbsp;&nbsp; ' were Nothing). In this case, Erase ResultArray.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Erase ResultArray
End If
'''''''''''''''''''''''''''''
' No errors were encountered.
' Return True.
'''''''''''''''''''''''''''''
CopyNonNothingObjectsToArray = True


End Function



Public Function DataTypeOfArray(Arr As Variant) As VbVarType
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' DataTypeOfArray
'
' Returns a VbVarType value indicating data type of the elements of
' Arr.
'
' The VarType of an array is the value vbArray plus the VbVarType value of the
' data type of the array. For example the VarType of an array of Longs is 8195,
' which equal to vbArray + vbLong. This code subtracts the value of vbArray to
' return the native data type.
'
' If Arr is a simple array, either single- or mulit-
' dimensional, the function returns the data type of the array. Arr
' may be an unallocated array. We can still get the data type of an unallocated
' array.
'
' If Arr is an array of arrays, the function returns vbArray. To retrieve
' the data type of a subarray, pass into the function one of the sub-arrays. E.g.,
' Dim R As VbVarType
' R = DataTypeOfArray(A(LBound(A)))
'
' This function support single and multidimensional arrays. It does not
' support user-defined types. If Arr is an array of empty variants (vbEmpty)
' it returns vbVariant
'
' Returns -1 if Arr is not an array.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Element As Variant
Dim NumDimensions As Long

' If Arr is not an array, return
' vbEmpty and get out.
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; DataTypeOfArray = -1
&nbsp;&nbsp;&nbsp; Exit Function
End If

If IsArrayEmpty(Arr) = True Then
&nbsp;&nbsp;&nbsp; ' If the array is unallocated, we can still get its data type.
&nbsp;&nbsp;&nbsp; ' The result of VarType of an array is vbArray + the VarType
&nbsp;&nbsp;&nbsp; ' of elements of the array (e.g., the VarType of an array of Longs
&nbsp;&nbsp;&nbsp; ' is 8195, which is vbArray + vbLong). Thus, to get the basic data
&nbsp;&nbsp;&nbsp; ' type of the array, we subtract the value vbArray.
&nbsp;&nbsp;&nbsp; DataTypeOfArray = VarType(Arr) - vbArray
Else
&nbsp;&nbsp;&nbsp; ' get the number of dimensions in the array.
&nbsp;&nbsp;&nbsp; NumDimensions = NumberOfArrayDimensions(Arr)
&nbsp;&nbsp;&nbsp; ' set variable Element to first element of the first dimension
&nbsp;&nbsp;&nbsp; ' of the array
&nbsp;&nbsp;&nbsp; If NumDimensions = 1 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(Arr(LBound(Arr))) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTypeOfArray = vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Element = Arr(LBound(Arr))
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(Arr(LBound(Arr), 1)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTypeOfArray = vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Element = Arr(LBound(Arr), 1)
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; ' if we were passed an array of arrays, IsArray(Element) will
&nbsp;&nbsp;&nbsp; ' be true. Therefore, return vbArray. If IsArray(Element) is false,
&nbsp;&nbsp;&nbsp; ' we weren't passed an array of arrays, so simply return the data type of
&nbsp;&nbsp;&nbsp; ' Element.
&nbsp;&nbsp;&nbsp; If IsArray(Element) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTypeOfArray = vbArray
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VarType(Element) = vbEmpty Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTypeOfArray = vbVariant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DataTypeOfArray = VarType(Element)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
End If


End Function

Public Function DeleteArrayElement(InputArray As Variant, ElementNumber As Long, _
&nbsp;&nbsp;&nbsp; Optional ResizeDynamic As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' DeleteArrayElement
' This function deletes an element from InputArray, and shifts elements that are to the
' right of the deleted element to the left. If InputArray is a dynamic array, and the
' ResizeDynamic parameter is True, the array will be resized one element smaller. Otherwise,
' the right-most entry in the array is set to the default value appropriate to the data
' type of the array (0, vbNullString, Empty, or Nothing). If the array is an array of Variant
' types, the default data type is the data type of the last element in the array.
' The function returns True if the elememt was successfully deleted, or False if an error
' occurrred. This procedure works only on single-dimensional
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Ndx As Long
Dim VType As VbVarType

''''''''''''''''''''''''''''''''
' Set the default result
''''''''''''''''''''''''''''''''
DeleteArrayElement = False

''''''''''''''''''''''''''''''''
' Ensure InputArray is an array.
''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''''
' Ensure we have a single dimensional array
'''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=InputArray) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''
' Ensure we have a valid ElementNumber
''''''''''''''''''''''''''''''''''''''''''''''
If (ElementNumber &lt; LBound(InputArray)) Or (ElementNumber &gt; UBound(InputArray)) Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

If LBound(InputArray) = UBound(InputArray) Then 
    Erase InputArray 
    Exit Function 
End If 
''''''''''''''''''''''''''''''''''''''''''''''
' Get the variable data type of the element
' we're deleting.
''''''''''''''''''''''''''''''''''''''''''''''
VType = VarType(InputArray(UBound(InputArray)))
If VType &gt;= vbArray Then
&nbsp;&nbsp;&nbsp; VType = VType - vbArray
End If
''''''''''''''''''''''''''''''''''''''''''''''
' Shift everything to the left
''''''''''''''''''''''''''''''''''''''''''''''
For Ndx = ElementNumber To UBound(InputArray) - 1
&nbsp;&nbsp;&nbsp; InputArray(Ndx) = InputArray(Ndx + 1)
Next Ndx
''''''''''''''''''''''''''''''''''''''''''''''
' If ResizeDynamic is True, resize the array
' if it is dynamic.
''''''''''''''''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr:=InputArray) = True Then
&nbsp;&nbsp;&nbsp; If ResizeDynamic = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Resize the array and get out.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim Preserve InputArray(LBound(InputArray) To UBound(InputArray) - 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteArrayElement = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
End If
'''''''''''''''''''''''''''''
' Set the last element of the
' InputArray to the proper
' default value.
'''''''''''''''''''''''''''''
Select Case VType
&nbsp;&nbsp;&nbsp; Case vbByte, vbInteger, vbLong, vbSingle, vbDouble, vbDate, vbCurrency, vbDecimal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(UBound(InputArray)) = 0
&nbsp;&nbsp;&nbsp; Case vbString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(UBound(InputArray)) = vbNullString
&nbsp;&nbsp;&nbsp; Case vbArray, vbVariant, vbEmpty, vbError, vbNull, vbUserDefinedType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(UBound(InputArray)) = Empty
&nbsp;&nbsp;&nbsp; Case vbBoolean
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(UBound(InputArray)) = False
&nbsp;&nbsp;&nbsp; Case vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set InputArray(UBound(InputArray)) = Nothing
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(UBound(InputArray)) = 0
End Select

DeleteArrayElement = True

End Function

Public Function FirstNonEmptyStringIndexInArray(InputArray As Variant) As Long
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' FirstNonEmptyStringIndexInArray
' This returns the index into InputArray of the first non-empty string.
' This is generally used when InputArray is the result of a sort operation,
' which puts empty strings at the beginning of the array.
' Returns -1 is an error occurred or if the entire array is empty strings.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Long

If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; FirstNonEmptyStringIndexInArray = -1
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;
Select Case NumberOfArrayDimensions(Arr:=InputArray)
&nbsp;&nbsp;&nbsp; Case 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' indicates an unallocated dynamic array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FirstNonEmptyStringIndexInArray = -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; Case 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' single dimensional array. OK.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' multidimensional array. Invalid.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FirstNonEmptyStringIndexInArray = -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select

For Ndx = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; If InputArray(Ndx) &lt;&gt; vbNullString Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FirstNonEmptyStringIndexInArray = Ndx
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
Next Ndx

FirstNonEmptyStringIndexInArray = -1
End Function


Public Function InsertElementIntoArray(InputArray As Variant, Index As Long, _
&nbsp;&nbsp;&nbsp; Value As Variant) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' InsertElementIntoArray
' This function inserts an element with a value of Value into InputArray at locatation Index.
' InputArray must be a dynamic array. The Value is stored in location Index, and everything
' to the right of Index is shifted to the right. The array is resized to make room for
' the new element. The value of Index must be greater than or equal to the LBound of
' InputArray and less than or equal to UBound+1. If Index is UBound+1, the Value is
' placed at the end of the array.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Long

'''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''
InsertElementIntoArray = False

''''''''''''''''''''''''''''''''
' Ensure InputArray is an array.
''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''
' Ensure InputArray is dynamic.
''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr:=InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''
' Ensure InputArray is allocated.
'''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''
' Ensure InputArray is a single
' dimensional array.
'''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=InputArray) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''
' Ensure Index is a valid element index.
' We allow Index to be equal to
' UBound + 1 to facilitate inserting
' a value at the end of the array. E.g.,
' InsertElementIntoArray(Arr,UBound(Arr)+1,123)
' will insert 123 at the end of the array.
'''''''''''''''''''''''''''''''''''''''''
If (Index &lt; LBound(InputArray)) Or (Index &gt; UBound(InputArray) + 1) Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''''''
' Resize the array
'''''''''''''''''''''''''''''''''''''''''''''
ReDim Preserve InputArray(LBound(InputArray) To UBound(InputArray) + 1)
'''''''''''''''''''''''''''''''''''''''''''''
' First, we set the newly created last element
' of InputArray to Value. This is done to trap
' an error 13, type mismatch. This last entry
' will be overwritten when we shift elements
' to the right, and the Value will be inserted
' at Index.
'''''''''''''''''''''''''''''''''''''''''''''''
On Error Resume Next
Err.Clear
InputArray(UBound(InputArray)) = Value
If Err.Number &lt;&gt; 0 Then
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' An error occurred, most likely
&nbsp;&nbsp;&nbsp; ' an error 13, type mismatch.
&nbsp;&nbsp;&nbsp; ' Redim the array back to its original
&nbsp;&nbsp;&nbsp; ' size and exit the function.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ReDim Preserve InputArray(LBound(InputArray) To UBound(InputArray) - 1)
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''''''''''''''
' Shift everything to the right.
'''''''''''''''''''''''''''''''''''''''''''''
For Ndx = UBound(InputArray) To Index + 1 Step -1
&nbsp;&nbsp;&nbsp; InputArray(Ndx) = InputArray(Ndx - 1)
Next Ndx

'''''''''''''''''''''''''''''''''''''''''''''
' Insert Value at Index
'''''''''''''''''''''''''''''''''''''''''''''
InputArray(Index) = Value

&nbsp;&nbsp;&nbsp;
InsertElementIntoArray = True


End Function



Public Function IsArrayAllDefault(InputArray As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayAllEmpty
' Returns True if the array contains all default values for its
' data type:
'&nbsp;&nbsp; Variable Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value
'&nbsp;&nbsp; -------------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------
'&nbsp;&nbsp; Variant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Empty
'&nbsp;&nbsp; String&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbNullString
'&nbsp;&nbsp; Numeric&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Long
Dim DefaultValue As Variant

'''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''
IsArrayAllDefault = False

'''''''''''''''''''''''''''''''''''
' Ensure InputArray is an array.
'''''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; IsArrayAllDefault = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure array is allocated. An
' unallocated is considered to be
' all the same type. Return True.
''''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=InputArray) = False Then
&nbsp;&nbsp;&nbsp; IsArrayAllDefault = True
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;
''''''''''''''''''''''''''''''''''
' Test the type of variable
''''''''''''''''''''''''''''''''''
Select Case VarType(InputArray)
&nbsp;&nbsp;&nbsp; Case vbArray + vbVariant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultValue = Empty
&nbsp;&nbsp;&nbsp; Case vbArray + vbString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultValue = vbNullString
&nbsp;&nbsp;&nbsp; Case Is &gt; vbArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultValue = 0
End Select
For Ndx = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; If IsObject(InputArray(Ndx)) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not InputArray(Ndx) Is Nothing Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VarType(InputArray(Ndx)) &lt;&gt; vbEmpty Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If InputArray(Ndx) &lt;&gt; DefaultValue Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
Next Ndx

'''''''''''''''''''''''''''''''
' If we make it out of the loop,
' the array is all defaults.
' Return True.
'''''''''''''''''''''''''''''''
IsArrayAllDefault = True


End Function



Public Function IsArrayAllNumeric(Arr As Variant, _
&nbsp;&nbsp;&nbsp; Optional AllowNumericStrings As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayAllNumeric
' This function returns True is Arr is entirely numeric. False otherwise. The AllowNumericStrings
' parameter indicates whether strings containing numeric data are considered numeric. If this
' parameter is True, a numeric string is considered a numeric variable. If this parameter is
' omitted or False, a numeric string is not considered a numeric variable.
' Variants that are numeric or Empty are allowed. Variants that are arrays, objects, or
' non-numeric data are not allowed.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Ndx As Long

''''''''''''''''''''''''''''
' Ensure Arr is an array.
''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Ensure Arr is allocated (non-empty).
''''''''''''''''''''''''''''''''''''''
If IsArrayEmpty(Arr:=Arr) = True Then
&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Loop through the array.
'''''''''''''''''''''''''''''''''''''
For Ndx = LBound(Arr) To UBound(Arr)
&nbsp;&nbsp;&nbsp; Select Case VarType(Arr(Ndx))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger, vbLong, vbDouble, vbSingle, vbCurrency, vbDecimal, vbEmpty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' all valid numeric types
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' For strings, check the AllowNumericStrings parameter.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If True and the element is a numeric string, allow it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If it is a non-numeric string, exit with False.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If AllowNumericStrings is False, all strings, even
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' numeric strings, will cause a result of False.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If AllowNumericStrings = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Allow numeric strings.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsNumeric(Arr(Ndx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbVariant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' For Variants, disallow Arrays and Objects.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' If the element is not an array or an object,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' test whether it is numeric. Allow numeric
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Varaints.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsArray(Arr(Ndx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(Arr(Ndx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsNumeric(Arr(Ndx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' any other data type returns False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End Select
Next Ndx

IsArrayAllNumeric = True

End Function



Public Function IsArrayAllocated(Arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayAllocated
' Returns TRUE if the array is allocated (either a static array or a dynamic array that has been
' sized with Redim) or FALSE if the array is not allocated (a dynamic that has not yet
' been sized with Redim, or a dynamic array that has been Erased). Static arrays are always
' allocated.
'
' The VBA IsArray function indicates whether a variable is an array, but it does not
' distinguish between allocated and unallocated arrays. It will return TRUE for both
' allocated and unallocated arrays. This function tests whether the array has actually
' been allocated.
'
' This function is just the reverse of IsArrayEmpty.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim N As Long
On Error Resume Next

' if Arr is not an array, return FALSE and get out.
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; IsArrayAllocated = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

' Attempt to get the UBound of the array. If the array has not been allocated,
' an error will occur. Test Err.Number to see if an error occurred.
N = UBound(Arr, 1)
If (Err.Number = 0) Then
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Under some circumstances, if an array
&nbsp;&nbsp;&nbsp; ' is not allocated, Err.Number will be
&nbsp;&nbsp;&nbsp; ' 0. To acccomodate this case, we test
&nbsp;&nbsp;&nbsp; ' whether LBound &lt;= Ubound. If this
&nbsp;&nbsp;&nbsp; ' is True, the array is allocated. Otherwise,
&nbsp;&nbsp;&nbsp; ' the array is not allocated.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If LBound(Arr) &lt;= UBound(Arr) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' no error. array has been allocated.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllocated = True
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllocated = False
&nbsp;&nbsp;&nbsp; End If
Else
&nbsp;&nbsp;&nbsp; ' error. unallocated array
&nbsp;&nbsp;&nbsp; IsArrayAllocated = False
End If

End Function



Public Function IsArrayDynamic(ByRef Arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayDynamic
' This function returns TRUE or FALSE indicating whether Arr is a dynamic array.
' Note that if you attempt to ReDim a static array in the same procedure in which it is
' declared, you'll get a compiler error and your code won't run at all.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim LUBound As Long

' If we weren't passed an array, get out now with a FALSE result
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; IsArrayDynamic = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

' If the array is empty, it hasn't been allocated yet, so we know
' it must be a dynamic array.
If IsArrayEmpty(Arr:=Arr) = True Then
&nbsp;&nbsp;&nbsp; IsArrayDynamic = True
&nbsp;&nbsp;&nbsp; Exit Function
End If

' Save the UBound of Arr.
' This value will be used to restore the original UBound if Arr
' is a single-dimensional dynamic array. Unused if Arr is multi-dimensional,
' or if Arr is a static array.
LUBound = UBound(Arr)

On Error Resume Next
Err.Clear

' Attempt to increase the UBound of Arr and test the value of Err.Number.
' If Arr is a static array, either single- or multi-dimensional, we'll get a
' C_ERR_ARRAY_IS_FIXED_OR_LOCKED error. In this case, return FALSE.
'
' If Arr is a single-dimensional dynamic array, we'll get C_ERR_NO_ERROR error.
'
' If Arr is a multi-dimensional dynamic array, we'll get a
' C_ERR_SUBSCRIPT_OUT_OF_RANGE error.
'
' For either C_NO_ERROR or C_ERR_SUBSCRIPT_OUT_OF_RANGE, return TRUE.
' For C_ERR_ARRAY_IS_FIXED_OR_LOCKED, return FALSE.

ReDim Preserve Arr(LBound(Arr) To LUBound + 1)

Select Case Err.Number
&nbsp;&nbsp;&nbsp; Case C_ERR_NO_ERROR
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' We successfully increased the UBound of Arr.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Do a ReDim Preserve to restore the original UBound.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ReDim Preserve Arr(LBound(Arr) To LUBound)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayDynamic = True
&nbsp;&nbsp;&nbsp; Case C_ERR_SUBSCRIPT_OUT_OF_RANGE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Arr is a multi-dimensional dynamic array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Return True.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayDynamic = True
&nbsp;&nbsp;&nbsp; Case C_ERR_ARRAY_IS_FIXED_OR_LOCKED
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Arr is a static single- or multi-dimensional array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Return False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayDynamic = False
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' We should never get here.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Some unexpected error occurred. Be safe and return False.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayDynamic = False
End Select

End Function


Public Function IsArrayEmpty(Arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayEmpty
' This function tests whether the array is empty (unallocated). Returns TRUE or FALSE.
'
' The VBA IsArray function indicates whether a variable is an array, but it does not
' distinguish between allocated and unallocated arrays. It will return TRUE for both
' allocated and unallocated arrays. This function tests whether the array has actually
' been allocated.
'
' This function is really the reverse of IsArrayAllocated.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim LB As Long
Dim UB As Long

Err.Clear
On Error Resume Next
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; ' we weren't passed an array, return True
&nbsp;&nbsp;&nbsp; IsArrayEmpty = True
End If

' Attempt to get the UBound of the array. If the array is
' unallocated, an error will occur.
UB = UBound(Arr, 1)
If (Err.Number &lt;&gt; 0) Then
&nbsp;&nbsp;&nbsp; IsArrayEmpty = True
Else
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' On rare occassion, under circumstances I
&nbsp;&nbsp;&nbsp; ' cannot reliably replictate, Err.Number
&nbsp;&nbsp;&nbsp; ' will be 0 for an unallocated, empty array.
&nbsp;&nbsp;&nbsp; ' On these occassions, LBound is 0 and
&nbsp;&nbsp;&nbsp; ' UBoung is -1.
&nbsp;&nbsp;&nbsp; ' To accomodate the weird behavior, test to
&nbsp;&nbsp;&nbsp; ' see if LB &gt; UB. If so, the array is not
&nbsp;&nbsp;&nbsp; ' allocated.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Err.Clear
&nbsp;&nbsp;&nbsp; LB = LBound(Arr)
&nbsp;&nbsp;&nbsp; If LB &gt; UB Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayEmpty = True
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayEmpty = False
&nbsp;&nbsp;&nbsp; End If
End If

End Function






Public Function IsArrayObjects(InputArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional AllowNothing As Boolean = True) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArrayObjects
' Returns True if InputArray is entirely objects (Nothing objects are
' optionally allowed -- default it true, allow Nothing objects). Set the
' AllowNothing to true or false to indicate whether Nothing objects
' are allowed.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Ndx As Long

''''''''''''''''''''''''''''''''
' Set the default return value.
''''''''''''''''''''''''''''''''
IsArrayObjects = False

''''''''''''''''''''''''''''''''
' Ensure InputArray is an array.
''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''
' Ensure we have a single dimensional
' array.
'''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(Arr:=InputArray)
&nbsp;&nbsp;&nbsp; Case 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Unallocated dynamic array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Not allowed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; Case 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' OK
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Multi-dimensional array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Not allowed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select

For Ndx = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; If IsObject(InputArray(Ndx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; If InputArray(Ndx) Is Nothing Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If AllowNothing = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
Next Ndx

IsArrayObjects = True

End Function




Public Function IsNumericDataType(TestVar As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsNumericDataType
'
' This function returns TRUE or FALSE indicating whether the data
' type of a variable is a numeric data type. It will return TRUE
' for all of the following data types:
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbCurrency
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbDecimal
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbDouble
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbInteger
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbLong
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vbSingle
'
' It will return FALSE for any other data type, including empty Variants and objects.
' If TestVar is an allocated array, it will test data type of the array
' and return TRUE or FALSE for that data type. If TestVar is an allocated
' array, it tests the data type of the first element of the array. If
' TestVar is an array of Variants, the function will indicate only whether
' the first element of the array is numeric. Other elements of the array
' may not be numeric data types. To test an entire array of variants
' to ensure they are all numeric data types, use the IsVariantArrayNumeric
' function.
'
' It will return FALSE for any other data type. Use this procedure
' instead of VBA's IsNumeric function because IsNumeric will return
' TRUE if the variable is a string containing numeric data. This
' will cause problems with code like
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim V1 As Variant
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim V2 As Variant
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V1 = "1"
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V2 = "2"
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsNumeric(V1) = True Then
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsNumeric(V2) = True Then
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Debug.Print V1 + V2
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
'
' The output of the Debug.Print statement will be "12", not 3,
' because V1 and V2 are strings and the '+' operator acts like
' the '&amp;' operator when used with strings. This can lead to
' unexpected results.
'
' IsNumeric should only be used to test strings for numeric content
' when converting a string value to a numeric variable.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Dim Element As Variant
&nbsp;&nbsp;&nbsp; Dim NumDims As Long
&nbsp;&nbsp;&nbsp; If IsArray(TestVar) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumDims = NumberOfArrayDimensions(Arr:=TestVar)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NumDims &gt; 1 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' this procedure does not support
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' multi-dimensional arrays.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsArrayAllocated(Arr:=TestVar) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Element = TestVar(LBound(TestVar))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case VarType(Element)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbCurrency, vbDecimal, vbDouble, vbInteger, vbLong, vbSingle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case VarType(TestVar) - vbArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbCurrency, vbDecimal, vbDouble, vbInteger, vbLong, vbSingle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Select Case VarType(TestVar)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbCurrency, vbDecimal, vbDouble, vbInteger, vbLong, vbSingle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsNumericDataType = False
&nbsp;&nbsp;&nbsp; End Select
End Function



Public Function IsVariantArrayConsistent(Arr As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsVariantArrayConsistent
'
' This returns TRUE or FALSE indicating whether an array of variants
' contains all the same data types. Returns FALSE under the following
' circumstances:
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arr is not an array
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arr is an array but is unallocated
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arr is a multidimensional array
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arr is allocated but does not contain consistant data types.
'
' If Arr is an array of objects, objects that are Nothing are ignored.
' As long as all non-Nothing objects are the same object type, the
' function returns True.
'
' It returns TRUE if all the elements of the array have the same
' data type. If Arr is an array of a specific data types, not variants,
' (E.g., Dim V(1 To 3) As Long), the function will return True. If
' an array of variants contains an uninitialized element (VarType =
' vbEmpty) that element is skipped and not used in the comparison. The
' reasoning behind this is that an empty variable will return the
' data type of the variable to which it is assigned (e.g., it will
' return vbNullString to a String and 0 to a Double).
'
' The function does not support arrays of User Defined Types.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim FirstDataType As VbVarType
Dim Ndx As Long
'''''''''''''''''''''''''''''''''''''''''
' Exit with False if Arr is not an array.
'''''''''''''''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''
' Exit with False if Arr is not allocated.
''''''''''''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr) = False Then
&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''''''''''''
' Exit with false on multi-dimensional
' arrays.
''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''
' Test if we have an array of a specific
' type rather than Variants. If so,
' return TRUE and get out.
''''''''''''''''''''''''''''''''''''''''''
If (VarType(Arr) &lt;= vbArray) And _
&nbsp;&nbsp;&nbsp; (VarType(Arr) &lt;&gt; vbVariant) Then
&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent = True
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''
' Get the data type of the first element.
''''''''''''''''''''''''''''''''''''''''''
FirstDataType = VarType(Arr(LBound(Arr)))
''''''''''''''''''''''''''''''''''''''''''
' Loop through the array and exit if
' a differing data type if found.
''''''''''''''''''''''''''''''''''''''''''
For Ndx = LBound(Arr) + 1 To UBound(Arr)
&nbsp;&nbsp;&nbsp; If VarType(Arr(Ndx)) &lt;&gt; vbEmpty Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(Arr(Ndx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If Not Arr(Ndx) Is Nothing Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VarType(Arr(Ndx)) &lt;&gt; FirstDataType Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VarType(Arr(Ndx)) &lt;&gt; FirstDataType Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayConsistent = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
Next Ndx

''''''''''''''''''''''''''''''''''''''''''
' If we make it out of the loop,
' then the array is consistent.
''''''''''''''''''''''''''''''''''''''''''
IsVariantArrayConsistent = True

End Function



Public Function IsVariantArrayNumeric(TestArray As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsVariantArrayNumeric
'
' This function return TRUE if all the elements of an array of
' variants are numeric data types. They need not all be the same data
' type. You can have a mix of Integer, Longs, Doubles, and Singles.
' As long as they are all numeric data types, the function will
' return TRUE. If a non-numeric data type is encountered, the
' function will return FALSE. Also, it will return FALSE if
' TestArray is not an array, or if TestArray has not been
' allocated. TestArray may be a multi-dimensional array. This
' procedure uses the IsNumericDataType function to determine whether
' a variable is a numeric data type. If there is an uninitialized
' variant (VarType = vbEmpty) in the array, it is skipped and not
' used in the comparison (i.e., Empty is considered a valid numeric
' data type since you can assign a number to it).
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Ndx As Long
Dim DimNdx As Long
Dim NumDims As Long

''''''''''''''''''''''''''''''''
' Ensure TestArray is an array.
''''''''''''''''''''''''''''''''
If IsArray(TestArray) = False Then
&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''
' Ensure that TestArray has been
' allocated.
''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=TestArray) = False Then
&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
''''''''''''''''''''''''''''''''''''
' Ensure the array is a one
' dimensional array. This procedure
' will not work on multi-dimensional
' arrays.
''''''''''''''''''''''''''''''''''''
'If NumberOfArrayDimensions(Arr:=TestArray) &gt; 1 Then
'&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric = False
'&nbsp;&nbsp;&nbsp; Exit Function
'End If
&nbsp;&nbsp;&nbsp;
NumDims = NumberOfArrayDimensions(Arr:=TestArray)
If NumDims = 1 Then
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' single dimensional array
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For Ndx = LBound(TestArray) To UBound(TestArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(TestArray(Ndx)) = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VarType(TestArray(Ndx)) &lt;&gt; vbEmpty Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsNumericDataType(TestVar:=TestArray(Ndx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Next Ndx
Else
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' multi-dimensional array
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For DimNdx = 1 To NumDims
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For Ndx = LBound(TestArray, DimNdx) To UBound(TestArray, DimNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VarType(TestArray(Ndx, DimNdx)) &lt;&gt; vbEmpty Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsNumericDataType(TestVar:=TestArray(Ndx, DimNdx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsVariantArrayNumeric = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next Ndx
&nbsp;&nbsp;&nbsp; Next DimNdx
End If

'''''''''''''''''''''''''''''''''''''''
' If we made it out of the loop, then
' the array is entirely numeric.
'''''''''''''''''''''''''''''''''''''''
IsVariantArrayNumeric = True

End Function



Public Function MoveEmptyStringsToEndOfArray(InputArray As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' This procedure takes the SORTED array InputArray, which, if sorted in
' ascending order, will have all empty strings at the front of the array.
' This procedure moves those strings to the end of the array, shifting
' the non-empty strings forward in the array.
' Note that InputArray MUST be sorted in ascending order.
' Returns True if the array was correctly shifted (if necessary) and False
' if an error occurred.
' This function uses the following functions, which are included as Private
' procedures at the end of this module.
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FirstNonEmptyStringIndexInArray
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumberOfArrayDimensions
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArrayAllocated

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Temp As String
Dim Ndx As Long
Dim Ndx2 As Long
Dim NonEmptyNdx As Long
Dim FirstNonEmptyNdx As Long


''''''''''''''''''''''''''''''''
' Ensure InpuyArray is an array.
''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; MoveEmptyStringsToEndOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If


''''''''''''''''''''''''''''''''''''
' Ensure that the array is allocated
' (not an empty array).
''''''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=InputArray) = False Then
&nbsp;&nbsp;&nbsp; MoveEmptyStringsToEndOfArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If


FirstNonEmptyNdx = FirstNonEmptyStringIndexInArray(InputArray:=InputArray)
If FirstNonEmptyNdx &lt;= LBound(InputArray) Then
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' No empty strings at the beginning of the
&nbsp;&nbsp;&nbsp; ' array. Get out now.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; MoveEmptyStringsToEndOfArray = True
&nbsp;&nbsp;&nbsp; Exit Function
End If


''''''''''''''''''''''''''''''''''''''''''''''''
' Loop through the array, swapping vbNullStrings
' at the beginning with values at the end.
''''''''''''''''''''''''''''''''''''''''''''''''
NonEmptyNdx = FirstNonEmptyNdx
For Ndx = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; If InputArray(Ndx) = vbNullString Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(Ndx) = InputArray(NonEmptyNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InputArray(NonEmptyNdx) = vbNullString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NonEmptyNdx = NonEmptyNdx + 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NonEmptyNdx &gt; UBound(InputArray) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit For
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
Next Ndx
''''''''''''''''''''''''''''''''''''''''''''''''''''
' Set entires (Ndx+1) to UBound(InputArray) to
' vbNullStrings.
''''''''''''''''''''''''''''''''''''''''''''''''''''
For Ndx2 = Ndx + 1 To UBound(InputArray)
&nbsp;&nbsp;&nbsp; InputArray(Ndx2) = vbNullString
Next Ndx2
MoveEmptyStringsToEndOfArray = True

End Function



Public Function NumberOfArrayDimensions(Arr As Variant) As Integer
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' NumberOfArrayDimensions
' This function returns the number of dimensions of an array. An unallocated dynamic array
' has 0 dimensions. This condition can also be tested with IsArrayEmpty.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Integer
Dim Res As Integer
On Error Resume Next
' Loop, increasing the dimension index Ndx, until an error occurs.
' An error will occur when Ndx exceeds the number of dimension
' in the array. Return Ndx - 1.
Do
&nbsp;&nbsp;&nbsp; Ndx = Ndx + 1
&nbsp;&nbsp;&nbsp; Res = UBound(Arr, Ndx)
Loop Until Err.Number &lt;&gt; 0

NumberOfArrayDimensions = Ndx - 1

End Function




Public Function NumElements(Arr As Variant, Optional Dimension = 1) As Long
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' NumElements
' Returns the number of elements in the specified dimension (Dimension) of the array in
' Arr. If you omit Dimension, the first dimension is used. The function will return
' 0 under the following circumstances:
'&nbsp;&nbsp;&nbsp;&nbsp; Arr is not an array, or
'&nbsp;&nbsp;&nbsp;&nbsp; Arr is an unallocated array, or
'&nbsp;&nbsp;&nbsp;&nbsp; Dimension is greater than the number of dimension of Arr, or
'&nbsp;&nbsp;&nbsp;&nbsp; Dimension is less than 1.
'
' This function does not support arrays of user-defined Type variables.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim NumDimensions As Long

' if Arr is not an array, return 0 and get out.
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; NumElements = 0
&nbsp;&nbsp;&nbsp; Exit Function
End If

' if the array is unallocated, return 0 and get out.
If IsArrayEmpty(Arr) = True Then
&nbsp;&nbsp;&nbsp; NumElements = 0
&nbsp;&nbsp;&nbsp; Exit Function
End If

' ensure that Dimension is at least 1.
If Dimension &lt; 1 Then
&nbsp;&nbsp;&nbsp; NumElements = 0
&nbsp;&nbsp;&nbsp; Exit Function
End If

' get the number of dimensions
NumDimensions = NumberOfArrayDimensions(Arr)
If NumDimensions &lt; Dimension Then
&nbsp;&nbsp;&nbsp; NumElements = 0
&nbsp;&nbsp;&nbsp; Exit Function
End If

' returns the number of elements in the array
NumElements = UBound(Arr, Dimension) - LBound(Arr, Dimension) + 1

End Function

Public Function ResetVariantArrayToDefaults(InputArray As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResetVariantArrayToDefaults
' This resets all the elements of an array of Variants back to their appropriate
' default values. The elements of the array may be of mixed types (e.g., some Longs,
' some Objects, some Strings, etc). Each data type will be set to the appropriate
' default value (0, vbNullString, Empty, or Nothing). It returns True if the
' array was set to defautls, or False if an error occurred. InputArray must be
' an allocated single-dimensional array. This function differs from the Erase
' function in that it preserves the original data types, while Erase sets every
' element to Empty.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Ndx As Long
'''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''
ResetVariantArrayToDefaults = False

'''''''''''''''''''''''''''''''
' Ensure InputArray is an array
'''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''
' Ensure InputArray is a single
' dimensional allocated array.
'''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=InputArray) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; Exit Function
End If

For Ndx = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; SetVariableToDefault InputArray(Ndx)
Next Ndx

ResetVariantArrayToDefaults = True

End Function


&nbsp;

Public Function ReverseArrayInPlace(InputArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional NoAlerts As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ReverseArrayInPlace
' This procedure reverses the order of an array in place -- this is, the array variable
' in the calling procedure is reversed. This works only on single-dimensional arrays
' of simple data types (String, Single, Double, Integer, Long). It will not work
' on arrays of objects. Use ReverseArrayOfObjectsInPlace to reverse an array of objects.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Temp As Variant
Dim Ndx As Long
Dim Ndx2 As Long


'''''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''''
ReverseArrayInPlace = False

'''''''''''''''''''''''''''''''''
' ensure we have an array
'''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "The InputArray parameter is not an array."
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Test the number of dimensions of the
' InputArray. If 0, we have an empty,
' unallocated array. Get out with
' an error message. If greater than
' one, we have a multi-dimensional
' array, which is not allowed. Only
' an allocated 1-dimensional array is
' allowed.
''''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(InputArray)
&nbsp;&nbsp;&nbsp; Case 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "The input array is an empty, unallocated array."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; Case 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' ok
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "The input array is multi-dimensional. ReverseArrayInPlace works only " &amp; _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "on single-dimensional arrays."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select

Ndx2 = UBound(InputArray)
''''''''''''''''''''''''''''''''''''''
' loop from the LBound of InputArray to
' the midpoint of InputArray
''''''''''''''''''''''''''''''''''''''
For Ndx = LBound(InputArray) To ((UBound(InputArray) - LBound(InputArray) + 1) \ 2)
&nbsp;&nbsp;&nbsp; 'swap the elements
&nbsp;&nbsp;&nbsp; Temp = InputArray(Ndx)
&nbsp;&nbsp;&nbsp; InputArray(Ndx) = InputArray(Ndx2)
&nbsp;&nbsp;&nbsp; InputArray(Ndx2) = Temp
&nbsp;&nbsp;&nbsp; ' decrement the upper index
&nbsp;&nbsp;&nbsp; Ndx2 = Ndx2 - 1
Next Ndx

''''''''''''''''''''''''''''''''''''''
' OK - Return True
''''''''''''''''''''''''''''''''''''''
ReverseArrayInPlace = True

End Function



Public Function ReverseArrayOfObjectsInPlace(InputArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional NoAlerts As Boolean = False) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ReverseArrayOfObjectsInPlace
' This procedure reverses the order of an array in place -- this is, the array variable
' in the calling procedure is reversed. This works only with arrays of objects. It does
' not work on simple variables. Use ReverseArrayInPlace for simple variables. An error
' will occur if an element of the array is not an object.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim Temp As Variant
Dim Ndx As Long
Dim Ndx2 As Long


'''''''''''''''''''''''''''''''''
' Set the default return value.
'''''''''''''''''''''''''''''''''
ReverseArrayOfObjectsInPlace = False

'''''''''''''''''''''''''''''''''
' ensure we have an array
'''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "The InputArray parameter is not an array."
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''
' Test the number of dimensions of the
' InputArray. If 0, we have an empty,
' unallocated array. Get out with
' an error message. If greater than
' one, we have a multi-dimensional
' array, which is not allowed. Only
' an allocated 1-dimensional array is
' allowed.
''''''''''''''''''''''''''''''''''''''
Select Case NumberOfArrayDimensions(InputArray)
&nbsp;&nbsp;&nbsp; Case 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "The input array is an empty, unallocated array."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; Case 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' ok
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "The input array is multi-dimensional. ReverseArrayInPlace works only " &amp; _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "on single-dimensional arrays."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select

Ndx2 = UBound(InputArray)

'''''''''''''''''''''''''''''''''''''
' ensure the entire array consists
' of objects (Nothing objects are
' allowed).
'''''''''''''''''''''''''''''''''''''
For Ndx = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; If IsObject(InputArray(Ndx)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NoAlerts = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MsgBox "Array item " &amp; CStr(Ndx) &amp; " is not an object."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
Next Ndx

''''''''''''''''''''''''''''''''''''''
' loop from the LBound of InputArray to
' the midpoint of InputArray
''''''''''''''''''''''''''''''''''''''
For Ndx = LBound(InputArray) To ((UBound(InputArray) - LBound(InputArray) + 1) \ 2)
&nbsp;&nbsp;&nbsp; Set Temp = InputArray(Ndx)
&nbsp;&nbsp;&nbsp; Set InputArray(Ndx) = InputArray(Ndx2)
&nbsp;&nbsp;&nbsp; Set InputArray(Ndx2) = Temp
&nbsp;&nbsp;&nbsp; ' decrement the upper index
&nbsp;&nbsp;&nbsp; Ndx2 = Ndx2 - 1
Next Ndx

''''''''''''''''''''''''''''''''''''''
' OK - Return True
''''''''''''''''''''''''''''''''''''''
ReverseArrayOfObjectsInPlace = True

End Function


Public Function SetObjectArrayToNothing(InputArray As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SetObjectArrrayToNothing
' This sets all the elements of InputArray to Nothing. Use this function
' rather than Erase because if InputArray is an array of Variants, Erase
' will set each element to Empty, not Nothing, and the element will cease
' to be an object.
'
' The function returns True if successful, False otherwise.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim N As Long

''''''''''''''''''''''''''''''''''''''
' Ensure InputArray is an array.
''''''''''''''''''''''''''''''''''''''
If IsArray(InputArray) = False Then
&nbsp;&nbsp;&nbsp; SetObjectArrayToNothing = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''
' Ensure we have a single-dimensional array.
''''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=InputArray) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; SetObjectArrayToNothing = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''''''
' Ensure the array is allocated and that each
' element is an object (or Nothing). If the
' array is not allocated, return True.
' We do this test before setting any element
' to Nothing so we don't end up with an array
' that is a mix of Empty and Nothing values.
' This means looping through the array twice,
' but it ensures all or none of the elements
' get set to Nothing.
''''''''''''''''''''''''''''''''''''''''''''''''
If IsArrayAllocated(Arr:=InputArray) = True Then
&nbsp;&nbsp;&nbsp; For N = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If IsObject(InputArray(N)) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetObjectArrayToNothing = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Next N
Else
&nbsp;&nbsp;&nbsp; SetObjectArrayToNothing = True
&nbsp;&nbsp;&nbsp; Exit Function
End If


'''''''''''''''''''''''''''''''''''''''''''''
' Set each element of InputArray to Nothing.
'''''''''''''''''''''''''''''''''''''''''''''
For N = LBound(InputArray) To UBound(InputArray)
&nbsp;&nbsp;&nbsp; Set InputArray(N) = Nothing
Next N

SetObjectArrayToNothing = True

End Function

Public Function AreDataTypesCompatible(DestVar As Variant, SourceVar As Variant) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' AreDataTypesCompatible
' This function determines if SourceVar is compatiable with DestVar. If the two
' data types are the same, they are compatible. If the value of SourceVar can
' be stored in DestVar with no loss of precision or an overflow, they are compatible.
' For example, if DestVar is a Long and SourceVar is an Integer, they are compatible
' because an integer can be stored in a Long with no loss of information. If DestVar
' is a Long and SourceVar is a Double, they are not compatible because information
' will be lost converting from a Double to a Long (the decimal portion will be lost).
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim SVType As VbVarType
Dim DVType As VbVarType

'''''''''''''''''''''''''''''''''''
' Set the default return type.
'''''''''''''''''''''''''''''''''''
AreDataTypesCompatible = False

'''''''''''''''''''''''''''''''''''
' If DestVar is an array, get the
' type of array. If it is an array
' its VarType is vbArray + VarType(element)
' so we subtract vbArray to get then
' data type of the aray. E.g.,
' the VarType of an array of Longs
' is 8195 = vbArray + vbLong,
' 8195 - vbArray = vbLong (=3).
'''''''''''''''''''''''''''''''''''
If IsArray(DestVar) = True Then
&nbsp;&nbsp;&nbsp; DVType = VarType(DestVar) - vbArray
Else
&nbsp;&nbsp;&nbsp; DVType = VarType(DestVar)
End If
'''''''''''''''''''''''''''''''''''
' If SourceVar is an array, get the
' type of array.
'''''''''''''''''''''''''''''''''''
If IsArray(SourceVar) = True Then
&nbsp;&nbsp;&nbsp; SVType = VarType(SourceVar) - vbArray
Else
&nbsp;&nbsp;&nbsp; SVType = VarType(SourceVar)
End If

''''''''''''''''''''''''''''''''''''
' If one variable is an array and
' the other is not an array, they
' are incompatible.
''''''''''''''''''''''''''''''''''''
If ((IsArray(DestVar) = True) And (IsArray(SourceVar) = False) Or _
&nbsp;&nbsp;&nbsp; (IsArray(DestVar) = False) And (IsArray(SourceVar) = True)) Then
&nbsp;&nbsp;&nbsp; Exit Function
End If


''''''''''''''''''''''''''''''''''''
' Test the data type of DestVar
' and return a result if SourceVar
' is compatible with that type.
''''''''''''''''''''''''''''''''''''
If SVType = DVType Then
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' The the variable types are the
&nbsp;&nbsp;&nbsp; ' same, they are compatible.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp; Exit Function
Else
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' If the data types are not the same,
&nbsp;&nbsp;&nbsp; ' determine whether they are compatible.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Select Case DVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbLong
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger, vbLong
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbSingle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger, vbLong, vbSingle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDouble
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger, vbLong, vbSingle, vbDouble
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbBoolean
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbBoolean, vbInteger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbByte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbByte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbCurrency
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger, vbLong, vbSingle, vbDouble
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDecimal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger, vbLong, vbSingle, vbDouble
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbLong, vbSingle, vbDouble
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbEmpty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbVariant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbError
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbNull
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Select Case SVType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End Select
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbVariant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AreDataTypesCompatible = True
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; End Select
End If


End Function

Public Sub SetVariableToDefault(ByRef Variable As Variant)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SetVariableToDefault
' This procedure sets Variable to the appropriate default
' value for its data type. Note that it cannot change User-Defined
' Types.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
If IsObject(Variable) Then
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' We test with IsObject here so that
&nbsp;&nbsp;&nbsp; ' the object itself, not the default
&nbsp;&nbsp;&nbsp; ' property of the object, is evaluated.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; Set Variable = Nothing
Else
&nbsp;&nbsp;&nbsp; Select Case VarType(Variable)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case Is &gt;= vbArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' The VarType of an array is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' equal to vbArray + VarType(ArrayElement).
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Here we check for anything &gt;= vbArray
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Erase Variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbBoolean
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbByte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CByte(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbCurrency
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CCur(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDataObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Variable = Nothing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CDate(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDecimal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CDec(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbDouble
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CDbl(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbEmpty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = Empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbError
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = Empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbInteger
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CInt(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbLong
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CLng(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbNull
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = Empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbObject
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set Variable = Nothing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbSingle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = CSng(0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = vbNullString
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbUserDefinedType
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' User-Defined-Types cannot be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' set to a general default value.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Each element must be explicitly
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' set to its default value. No
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' assignment takes place in this
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' procedure.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Case vbVariant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' This case is included for constistancy,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' but we will never get here. If the Variant
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' contains data, VarType returns the type of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' that data. An Empty Variant is type vbEmpty.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Variable = Empty
&nbsp;&nbsp;&nbsp; End Select
End If

End Sub
</font></pre>
        <pre><font color="#003366">Public Function TransposeArray(InputArr As Variant, OutputArr As Variant) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' TransposeArray
' This transposes a two-dimensional array. It returns True if successful or
' False if an error occurs. InputArr must be two-dimensions. OutputArr must be
' a dynamic array. It will be Erased and resized, so any existing content will
' be destroyed.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim RowNdx As Long
Dim ColNdx As Long
Dim LB1 As Long
Dim LB2 As Long
Dim UB1 As Long
Dim UB2 As Long

'''''''''''''''''''''''''''''''''''
' Ensure InputArr and OutputArr
' are arrays.
'''''''''''''''''''''''''''''''''''
If (IsArray(InputArr) = False) Or (IsArray(OutputArr) = False) Then
&nbsp;&nbsp;&nbsp; TransposeArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''
' Ensure OutputArr is a dynamic
' array.
'''''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr:=OutputArr) = False Then
&nbsp;&nbsp;&nbsp; TransposeArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure InputArr is two-dimensions,
' no more, no lesss.
''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=InputArr) &lt;&gt; 2 Then
&nbsp;&nbsp;&nbsp; TransposeArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''
' Get the Lower and Upper bounds of
' InputArr.
'''''''''''''''''''''''''''''''''''''''
LB1 = LBound(InputArr, 1)
LB2 = LBound(InputArr, 2)
UB1 = UBound(InputArr, 1)
UB2 = UBound(InputArr, 2)

'''''''''''''''''''''''''''''''''''''''''
' Erase and ReDim OutputArr
'''''''''''''''''''''''''''''''''''''''''
Erase OutputArr
ReDim OutputArr(LB2 To LB2 + UB2 - LB2, LB1 To LB1 + UB1 - LB1)

For RowNdx = LBound(InputArr, 2) To UBound(InputArr, 2)
&nbsp;&nbsp;&nbsp; For ColNdx = LBound(InputArr, 1) To UBound(InputArr, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputArr(RowNdx, ColNdx) = InputArr(ColNdx, RowNdx)
&nbsp;&nbsp;&nbsp; Next ColNdx
Next RowNdx

TransposeArray = True

End Function</font></pre><pre><font color="#003366">Public Function VectorsToArray(Arr As Variant, ParamArray Vectors()) As Boolean
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' VectorsToArray
' This function takes 1 or more single-dimensional arrays and converts
' them into a single multi-dimensional array. Each array in Vectors
' comprises one row of the new array. The number of columns in the
' new array is the maximum of the number of elements in each vector.
' Arr MUST be a dynamic array of a data type compatible with ALL the
' elements in each Vector. The code does NOT trap for an error
' 13 - Type Mismatch.
'
' If the Vectors are of differing sizes, Arr is sized to hold the
' maximum number of elements in a Vector. The procedure Erases the
' Arr array, so when it is reallocated with Redim, all elements will
' be the reset to their default value (0 or vbNullString or Empty).
' Unused elements in the new array will remain the default value for
' that data type.
'
' Each Vector in Vectors must be a single dimensional array, but
' the Vectors may be of different sizes and LBounds.
'
' Each element in each Vector must be a simple data type. The elements
' may NOT be Object, Arrays, or User-Defined Types.
'
' The rows and columns of the result array are 0-based, regardless of
' the LBound of each vector and regardless of the Option Base statement.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Vector As Variant
Dim VectorNdx As Long
Dim NumElements As Long
Dim NumRows As Long
Dim NumCols As Long
Dim RowNdx As Long
Dim ColNdx As Long
Dim VType As VbVarType

'''''''''''''''''''''''''''''''''''
' Ensure we have an Array
''''''''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure we have a dynamic array
''''''''''''''''''''''''''''''''''
If IsArrayDynamic(Arr) = False Then
&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;
'''''''''''''''''''''''''''''''''
' Ensure that at least one vector
' was passed in Vectors
'''''''''''''''''''''''''''''''''
If IsMissing(Vectors) = True Then
&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''''''''
' Loop through Vectors to determine the
' size of the result array. We do this
' loop first to prevent having to do
' a Redim Preserve. This requires looping
' through Vectors a second time, but this
' is still faster than doing Redim Preserves.
'''''''''''''''''''''''''''''''''''''''''''''''
For Each Vector In Vectors
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Ensure Vector is single
&nbsp;&nbsp;&nbsp; ' dimensional array. This
&nbsp;&nbsp;&nbsp; ' will take care of the case
&nbsp;&nbsp;&nbsp; ' if Vector is an unallocated
&nbsp;&nbsp;&nbsp; ' array (NumberOfArrayDimensions = 0
&nbsp;&nbsp;&nbsp; ' for an unallocated array).
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If NumberOfArrayDimensions(Vector) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Ensure that Vector is not an array.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; If IsArray(Vector) = False Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Increment the number of rows.
&nbsp;&nbsp;&nbsp; ' Each Vector is one row or the
&nbsp;&nbsp;&nbsp; ' result array. Test the size
&nbsp;&nbsp;&nbsp; ' of Vector. If it is larger
&nbsp;&nbsp;&nbsp; ' than the existing value of
&nbsp;&nbsp;&nbsp; ' NumCols, set NumCols to the
&nbsp;&nbsp;&nbsp; ' new, larger, value.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; NumRows = NumRows + 1
&nbsp;&nbsp;&nbsp; If NumCols &lt; UBound(Vector) - LBound(Vector) + 1 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumCols = UBound(Vector) - LBound(Vector) + 1
&nbsp;&nbsp;&nbsp; End If
Next Vector
''''''''''''''''''''''''''''''''''''''''''''
' Redim Arr to the appropriate size. Arr
' is 0-based in both directions, regardless
' of the LBound of the original Arr and
' regardless of the LBounds of the Vectors.
''''''''''''''''''''''''''''''''''''''''''''
ReDim Arr(0 To NumRows - 1, 0 To NumCols - 1)

'''''''''''''''''''''''''''''''
' Loop row-by-row.
For RowNdx = 0 To NumRows - 1
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Loop through the columns.
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For ColNdx = 0 To NumCols - 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Set Vector (a Variant) to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' the Vectors(RowNdx) array.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' We declare Vector as a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' variant so it can take an
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' array of any simple data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' type.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vector = Vectors(RowNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' The vectors need not ber
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If ColNdx &lt; UBound(Vector) - LBound(Vector) + 1 Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VType = VarType(Vector(LBound(Vector) + ColNdx))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VType &gt;= vbArray Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Test for VType &gt;= vbArray. The VarType of an array
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' is vbArray + VarType(element of array). E.g., the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' VarType of an array of Longs equal vbArray + vbLong.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Anything greater than or equal to vbArray is an
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' array of some time.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If VType = vbObject Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VectorsToArray = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Vector(LBound(Vector) + ColNdx) is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' a simple data type. If Vector(LBound(Vector) + ColNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' is not a compatible data type with Arr, then a Type
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Mismatch error will occur. We do NOT trap this error.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arr(RowNdx, ColNdx) = Vector(LBound(Vector) + ColNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Next ColNdx
Next RowNdx

VectorsToArray = True

End Function
</font></pre><pre><font color="#003366">Public Function IsArraySorted(TestArray As Variant, _
&nbsp;&nbsp;&nbsp; Optional Descending As Boolean = False) As Variant
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' IsArraySorted
' This function determines whether a single-dimensional array is sorted. Because
' sorting is an expensive operation, especially so on large array of Variants,
' you may want to determine if an array is already in sorted order prior to
' doing an actual sort.
' This function returns True if an array is in sorted order (either ascending or
' descending order, depending on the value of the Descending parameter -- default
' is false = Ascending). The decision to do a string comparison (with StrComp) or
' a numeric comparison (with &lt; or &gt;) is based on the data type of the first
' element of the array.
' If TestArray is not an array, is an unallocated dynamic array, or has more than
' one dimension, or the VarType of TestArray is not compatible, the function
' returns NULL.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim StrCompResultFail As Long
Dim NumericResultFail As Boolean
Dim Ndx As Long
Dim NumCompareResult As Boolean
Dim StrCompResult As Long

Dim IsString As Boolean
Dim VType As VbVarType

''''''''''''''''''''''''''''''''''
' Ensure TestArray is an array.
''''''''''''''''''''''''''''''''''
If IsArray(TestArray) = False Then
&nbsp;&nbsp;&nbsp; IsArraySorted = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''''''''''
' Ensure we have a single dimensional array.
''''''''''''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=TestArray) &lt;&gt; 1 Then
&nbsp;&nbsp;&nbsp; IsArraySorted = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''''''
' The following code sets the values of
' comparison that will indicate that the
' array is unsorted. It the result of
' StrComp (for strings) or "&gt;=" (for
' numerics) equals the value specified
' below, we know that the array is
' unsorted.
'''''''''''''''''''''''''''''''''''''''''''''
If Descending = True Then
&nbsp;&nbsp;&nbsp; StrCompResultFail = -1
&nbsp;&nbsp;&nbsp; NumericResultFail = False
Else
&nbsp;&nbsp;&nbsp; StrCompResultFail = 1
&nbsp;&nbsp;&nbsp; NumericResultFail = True
End If

''''''''''''''''''''''''''''''''''''''''''''''
' Determine whether we are going to do a string
' comparison or a numeric comparison.
''''''''''''''''''''''''''''''''''''''''''''''
VType = VarType(TestArray(LBound(TestArray)))
Select Case VType
&nbsp;&nbsp;&nbsp; Case vbArray, vbDataObject, vbEmpty, vbError, vbNull, vbObject, vbUserDefinedType
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Unsupported types. Reutrn Null.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArraySorted = Null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp; Case vbString, vbVariant
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Compare as string
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsString = True
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Compare as numeric
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsString = False
End Select

For Ndx = LBound(TestArray) To UBound(TestArray) - 1
&nbsp;&nbsp;&nbsp; If IsString = True Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StrCompResult = StrComp(TestArray(Ndx), TestArray(Ndx + 1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If StrCompResult = StrCompResultFail Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArraySorted = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NumCompareResult = (TestArray(Ndx) &gt;= TestArray(Ndx + 1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NumCompareResult = NumericResultFail Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IsArraySorted = False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End If
&nbsp;&nbsp;&nbsp; End If
Next Ndx


''''''''''''''''''''''''''''
' If we made it out of&nbsp; the
' loop, then the array is
' in sorted order. Return
' True.
''''''''''''''''''''''''''''
IsArraySorted = True

End Function</font></pre><pre><font color="#003366">Public Function CombineTwoDArrays(Arr1 As Variant, _
&nbsp;&nbsp;&nbsp; Arr2 As Variant) As Variant
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' TwoArraysToOneArray
' This takes two 2-dimensional arrays, Arr1 and Arr2, and
' returns an array combining the two. The number of Rows
' in the result is NumRows(Arr1) + NumRows(Arr2). Arr1 and
' Arr2 must have the same number of columns, and the result
' array will have that many columns. All the LBounds must
' be the same. E.g.,
' The following arrays are legal:
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim Arr1(0 To 4, 0 To 10)
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim Arr2(0 To 3, 0 To 10)
'
' The following arrays are illegal
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim Arr1(0 To 4, 1 To 10)
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim Arr2(0 To 3, 0 To 10)
'
' The returned result array is Arr1 with additional rows
' appended from Arr2. For example, the arrays
'&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp; b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and&nbsp;&nbsp;&nbsp;&nbsp; e&nbsp;&nbsp;&nbsp; f
'&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp; d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g&nbsp;&nbsp;&nbsp; h
' become
'&nbsp;&nbsp;&nbsp; a&nbsp;&nbsp;&nbsp; b
'&nbsp;&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp; d
'&nbsp;&nbsp;&nbsp; e&nbsp;&nbsp;&nbsp; f
'&nbsp;&nbsp;&nbsp; g&nbsp;&nbsp;&nbsp; h
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''''''''
' Upper and lower bounds of Arr1.
'''''''''''''''''''''''''''''''''
Dim LBoundRow1 As Long
Dim UBoundRow1 As Long
Dim LBoundCol1 As Long
Dim UBoundCol1 As Long

'''''''''''''''''''''''''''''''''
' Upper and lower bounds of Arr2.
'''''''''''''''''''''''''''''''''
Dim LBoundRow2 As Long
Dim UBoundRow2 As Long
Dim LBoundCol2 As Long
Dim UBoundCol2 As Long

'''''''''''''''''''''''''''''''''''
' Upper and lower bounds of Result.
'''''''''''''''''''''''''''''''''''
Dim LBoundRowResult As Long
Dim UBoundRowResult As Long
Dim LBoundColResult As Long
Dim UBoundColResult As Long

'''''''''''''''''
' Index Variables
'''''''''''''''''
Dim RowNdx1 As Long
Dim ColNdx1 As Long
Dim RowNdx2 As Long
Dim ColNdx2 As Long
Dim RowNdxResult As Long
Dim ColNdxResult As Long


'''''''''''''
' Array Sizes
'''''''''''''
Dim NumRows1 As Long
Dim NumCols1 As Long

Dim NumRows2 As Long
Dim NumCols2 As Long

Dim NumRowsResult As Long
Dim NumColsResult As Long

Dim Done As Boolean
Dim Result() As Variant
Dim ResultTrans() As Variant

Dim V As Variant


'''''''''''''''''''''''''''''''
' Ensure that Arr1 and Arr2 are
' arrays.
''''''''''''''''''''''''''''''
If (IsArray(Arr1) = False) Or (IsArray(Arr2) = False) Then
&nbsp;&nbsp;&nbsp; CombineTwoDArrays = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure both arrays are allocated
' two dimensional arrays.
''''''''''''''''''''''''''''''''''
If (NumberOfArrayDimensions(Arr1) &lt;&gt; 2) Or (NumberOfArrayDimensions(Arr2) &lt;&gt; 2) Then
&nbsp;&nbsp;&nbsp; CombineTwoDArrays = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;
'''''''''''''''''''''''''''''''''''''''
' Ensure that the LBound and UBounds
' of the second dimension are the
' same for both Arr1 and Arr2.
'''''''''''''''''''''''''''''''''''''''

''''''''''''''''''''''''''
' Get the existing bounds.
''''''''''''''''''''''''''
LBoundRow1 = LBound(Arr1, 1)
UBoundRow1 = UBound(Arr1, 1)

LBoundCol1 = LBound(Arr1, 2)
UBoundCol1 = UBound(Arr1, 2)

LBoundRow2 = LBound(Arr2, 1)
UBoundRow2 = UBound(Arr2, 1)

LBoundCol2 = LBound(Arr2, 2)
UBoundCol2 = UBound(Arr2, 2)

''''''''''''''''''''''''''''''''''''''''''''''''''
' Get the total number of rows for the result
' array.
''''''''''''''''''''''''''''''''''''''''''''''''''
NumRows1 = UBoundRow1 - LBoundRow1 + 1
NumCols1 = UBoundCol1 - LBoundCol1 + 1
NumRows2 = UBoundRow2 - LBoundRow2 + 1
NumCols2 = UBoundCol2 - LBoundCol2 + 1

'''''''''''''''''''''''''''''''''''''''''
' Ensure the number of columns are equal.
'''''''''''''''''''''''''''''''''''''''''
If NumCols1 &lt;&gt; NumCols2 Then
&nbsp;&nbsp;&nbsp; CombineTwoDArrays = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

NumRowsResult = NumRows1 + NumRows2

'''''''''''''''''''''''''''''''''''''''
' Ensure that ALL the LBounds are equal.
''''''''''''''''''''''''''''''''''''''''
If (LBoundRow1 &lt;&gt; LBoundRow2) Or _
&nbsp;&nbsp;&nbsp; (LBoundRow1 &lt;&gt; LBoundCol1) Or _
&nbsp;&nbsp;&nbsp; (LBoundRow1 &lt;&gt; LBoundCol2) Then
&nbsp;&nbsp;&nbsp; CombineTwoDArrays = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''
' Get the LBound of the columns
' of the result array.
'''''''''''''''''''''''''''''''
LBoundColResult = LBoundRow1
'''''''''''''''''''''''''''''''
' Get the UBound of the columns
' of the result array.
'''''''''''''''''''''''''''''''
UBoundColResult = UBoundCol1

UBoundRowResult = LBound(Arr1, 1) + NumRows1 + NumRows2 - 1
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Redim the Result array to have number of rows equal to
' number-of-rows(Arr1) + number-of-rows(Arr2)
' and number-of-columns equal to number-of-columns(Arr1)
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
ReDim Result(LBoundRow1 To UBoundRowResult, LBoundColResult To UBoundColResult)

RowNdxResult = LBound(Result, 1) - 1

Done = False
Do Until Done
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Copy elements of Arr1 to Result
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For RowNdx1 = LBound(Arr1, 1) To UBound(Arr1, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RowNdxResult = RowNdxResult + 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ColNdx1 = LBound(Arr1, 2) To UBound(Arr1, 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V = Arr1(RowNdx1, ColNdx1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result(RowNdxResult, ColNdx1) = V
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ColNdx1
&nbsp;&nbsp;&nbsp; Next RowNdx1

&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Copy elements of Arr2 to Result
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For RowNdx2 = LBound(Arr2, 1) To UBound(Arr2, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RowNdxResult = RowNdxResult + 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ColNdx2 = LBound(Arr2, 2) To UBound(Arr2, 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V = Arr2(RowNdx2, ColNdx2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result(RowNdxResult, ColNdx2) = V
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ColNdx2
&nbsp;&nbsp;&nbsp; Next RowNdx2
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; If RowNdxResult &gt;= UBound(Result, 1) + (LBoundColResult = 1) Then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Done = True
&nbsp;&nbsp;&nbsp; End If
'''''''''''''
' End Of Loop
'''''''''''''
Loop
'''''''''''''''''''''''''
' Return the Result
'''''''''''''''''''''''''
CombineTwoDArrays = Result

End Function
</font></pre><pre><font color="#003366">Function ExpandArray(Arr As Variant, WhichDim As Long, AdditionalElements As Long, _
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FillValue As Variant) As Variant
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ExpandArray
' This expands a two-dimensional array in either dimension. It returns the result
' array if successful, or NULL if an error occurred. The original array is never
' changed.
' Paramters:
' --------------------
' Arr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is the array to be expanded.
'
' WhichDim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is either 1 for additional rows or 2 for
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; additional columns.
'
' AdditionalElements&nbsp;&nbsp;&nbsp; is the number of additional rows or columns
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to create.
'
' FillValue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is the value to which the new array elements should be
'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initialized.
'
' You can nest calls to Expand array to expand both the number of rows and
' columns. E.g.,
'
' C = ExpandArray(ExpandArray(Arr:=A, WhichDim:=1, AdditionalElements:=3, FillValue:="R"), _
'&nbsp;&nbsp;&nbsp; WhichDim:=2, AdditionalElements:=4, FillValue:="C")
' This first adds three rows at the bottom of the array, and then adds four
' columns on the right of the array.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim Result As Variant
Dim RowNdx As Long
Dim ColNdx As Long
Dim ResultRowNdx As Long
Dim ResultColNdx As Long
Dim NumRows As Long
Dim NumCols As Long
Dim NewUBound As Long

Const ROWS_ As Long = 1
Const COLS_ As Long = 2


''''''''''''''''''''''''''''
' Ensure Arr is an array.
''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; ExpandArray = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''
' Ensure Arr has two dimenesions.
'''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=Arr) &lt;&gt; 2 Then
&nbsp;&nbsp;&nbsp; ExpandArray = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
'''''''''''''''''''''''''''''''''
' Ensure the dimension is 1 or 2.
'''''''''''''''''''''''''''''''''
Select Case WhichDim
&nbsp;&nbsp;&nbsp; Case 1, 2
&nbsp;&nbsp;&nbsp; Case Else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ExpandArray = Null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Exit Function
End Select

''''''''''''''''''''''''''''''''''''
' Ensure AdditionalElements is &gt; 0.
' If AdditionalElements&nbsp; &lt; 0, return NULL.
' If AdditionalElements&nbsp; = 0, return Arr.
''''''''''''''''''''''''''''''''''''
If AdditionalElements &lt; 0 Then
&nbsp;&nbsp;&nbsp; ExpandArray = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
If AdditionalElements = 0 Then
&nbsp;&nbsp;&nbsp; ExpandArray = Arr
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;
NumRows = UBound(Arr, 1) - LBound(Arr, 1) + 1
NumCols = UBound(Arr, 2) - LBound(Arr, 2) + 1
&nbsp;&nbsp;
If WhichDim = ROWS_ Then
&nbsp;&nbsp;&nbsp; '''''''''''''''
&nbsp;&nbsp;&nbsp; ' Redim Result.
&nbsp;&nbsp;&nbsp; '''''''''''''''
&nbsp;&nbsp;&nbsp; ReDim Result(LBound(Arr, 1) To UBound(Arr, 1) + AdditionalElements, LBound(Arr, 2) To UBound(Arr, 2))
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Transfer Arr array to Result
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For RowNdx = LBound(Arr, 1) To UBound(Arr, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ColNdx = LBound(Arr, 2) To UBound(Arr, 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result(RowNdx, ColNdx) = Arr(RowNdx, ColNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ColNdx
&nbsp;&nbsp;&nbsp; Next RowNdx
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Fill the rest of the result
&nbsp;&nbsp;&nbsp; ' array with FillValue.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For RowNdx = UBound(Arr, 1) + 1 To UBound(Result, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ColNdx = LBound(Arr, 2) To UBound(Arr, 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result(RowNdx, ColNdx) = FillValue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ColNdx
&nbsp;&nbsp;&nbsp; Next RowNdx
Else
&nbsp;&nbsp;&nbsp; '''''''''''''''
&nbsp;&nbsp;&nbsp; ' Redim Result.
&nbsp;&nbsp;&nbsp; '''''''''''''''
&nbsp;&nbsp;&nbsp; ReDim Result(LBound(Arr, 1) To UBound(Arr, 1), UBound(Arr, 2) + AdditionalElements)
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Transfer Arr array to Result
&nbsp;&nbsp;&nbsp; ''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For RowNdx = LBound(Arr, 1) To UBound(Arr, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ColNdx = LBound(Arr, 2) To UBound(Arr, 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result(RowNdx, ColNdx) = Arr(RowNdx, ColNdx)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ColNdx
&nbsp;&nbsp;&nbsp; Next RowNdx
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; ' Fill the rest of the result
&nbsp;&nbsp;&nbsp; ' array with FillValue.
&nbsp;&nbsp;&nbsp; '''''''''''''''''''''''''''''''
&nbsp;&nbsp;&nbsp; For RowNdx = LBound(Arr, 1) To UBound(Arr, 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For ColNdx = UBound(Arr, 2) + 1 To UBound(Result, 2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result(RowNdx, ColNdx) = FillValue
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next ColNdx
&nbsp;&nbsp;&nbsp; Next RowNdx
&nbsp;&nbsp;&nbsp;
End If
''''''''''''''''''''
' Return the result.
''''''''''''''''''''
ExpandArray = Result

End Function
</font></pre><pre><font color="#003366">Function SwapArrayRows(Arr As Variant, Row1 As Long, Row2 As Long) As Variant
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SwapArrayRows
' This function returns an array based on Arr with Row1 and Row2 swapped.
' It returns the result array or NULL if an error occurred.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim V As Variant
Dim Result As Variant
Dim RowNdx As Long
Dim ColNdx As Long

'''''''''''''''''''''''''
' Ensure Arr is an array.
'''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; SwapArrayRows = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''
' Set Result to Arr
''''''''''''''''''''''''''''''''
Result = Arr

''''''''''''''''''''''''''''''''
' Ensure Arr is two-dimensional.
''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=Arr) &lt;&gt; 2 Then
&nbsp;&nbsp;&nbsp; SwapArrayRows = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''
' Ensure Row1 and Row2 are less
' than or equal to the number of
' rows.
''''''''''''''''''''''''''''''''
If (Row1 &gt; UBound(Arr, 1)) Or (Row2 &gt; UBound(Arr, 1)) Then
&nbsp;&nbsp;&nbsp; SwapArrayRows = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;
'''''''''''''''''''''''''''''''''
' If Row1 = Row2, just return the
' array and exit. Nothing to do.
'''''''''''''''''''''''''''''''''
If Row1 = Row2 Then
&nbsp;&nbsp;&nbsp; SwapArrayRows = Arr
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''
' Redim V to the number of columns.
'''''''''''''''''''''''''''''''''''''''''
ReDim V(LBound(Arr, 2) To UBound(Arr, 2))
'''''''''''''''''''''''''''''''''''''''''
' Put Row1 in V
'''''''''''''''''''''''''''''''''''''''''
For ColNdx = LBound(Arr, 2) To UBound(Arr, 2)
&nbsp;&nbsp;&nbsp; V(ColNdx) = Arr(Row1, ColNdx)
&nbsp;&nbsp;&nbsp; Result(Row1, ColNdx) = Arr(Row2, ColNdx)
&nbsp;&nbsp;&nbsp; Result(Row2, ColNdx) = V(ColNdx)
Next ColNdx

SwapArrayRows = Result

End Function


Function SwapArrayColumns(Arr As Variant, Col1 As Long, Col2 As Long) As Variant
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' SwapArrayColumns
' This function returns an array based on Arr with Col1 and Col2 swapped.
' It returns the result array or NULL if an error occurred.
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim V As Variant
Dim Result As Variant
Dim RowNdx As Long
Dim ColNdx As Long

'''''''''''''''''''''''''
' Ensure Arr is an array.
'''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; SwapArrayColumns = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''
' Set Result to Arr
''''''''''''''''''''''''''''''''
Result = Arr

''''''''''''''''''''''''''''''''
' Ensure Arr is two-dimensional.
''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr:=Arr) &lt;&gt; 2 Then
&nbsp;&nbsp;&nbsp; SwapArrayColumns = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''
' Ensure Row1 and Row2 are less
' than or equal to the number of
' rows.
''''''''''''''''''''''''''''''''
If (Col1 &gt; UBound(Arr, 2)) Or (Col2 &gt; UBound(Arr, 2)) Then
&nbsp;&nbsp;&nbsp; SwapArrayColumns = Null
&nbsp;&nbsp;&nbsp; Exit Function
End If
&nbsp;&nbsp;&nbsp;
'''''''''''''''''''''''''''''''''
' If Col1 = Col2, just return the
' array and exit. Nothing to do.
'''''''''''''''''''''''''''''''''
If Col1 = Col2 Then
&nbsp;&nbsp;&nbsp; SwapArrayColumns = Arr
&nbsp;&nbsp;&nbsp; Exit Function
End If

'''''''''''''''''''''''''''''''''''''''''
' Redim V to the number of columns.
'''''''''''''''''''''''''''''''''''''''''
ReDim V(LBound(Arr, 1) To UBound(Arr, 1))
'''''''''''''''''''''''''''''''''''''''''
' Put Col2 in V
'''''''''''''''''''''''''''''''''''''''''
For RowNdx = LBound(Arr, 1) To UBound(Arr, 1)
&nbsp;&nbsp;&nbsp; V(RowNdx) = Arr(RowNdx, Col1)
&nbsp;&nbsp;&nbsp; Result(RowNdx, Col1) = Arr(RowNdx, Col2)
&nbsp;&nbsp;&nbsp; Result(RowNdx, Col2) = V(RowNdx)
Next RowNdx

SwapArrayColumns = Result

End Function
</font></pre><pre><font color="#003366">Function GetColumn(Arr As Variant, ResultArr As Variant, ColumnNumber As Long) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetColumn
' This populates ResultArr with a one-dimensional array that is the
' specified column of Arr. The existing contents of ResultArr are
' destroyed. ResultArr must be a dynamic array.
' Returns True or False indicating success.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim RowNdx As Long
''''''''''''''''''''''''''''''
' Ensure Arr is an array.
''''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; GetColumn = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure Arr is a two-dimensional
' array.
''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr) &lt;&gt; 2 Then
&nbsp;&nbsp;&nbsp; GetColumn = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure ResultArr is a dynamic
' array.
''''''''''''''''''''''''''''''''''
If IsArrayDynamic(ResultArr) = False Then
&nbsp;&nbsp;&nbsp; GetColumn = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''
' Ensure ColumnNumber is less than
' or equal to the number of columns.
''''''''''''''''''''''''''''''''''''
If UBound(Arr, 2) &lt; ColumnNumber Then
&nbsp;&nbsp;&nbsp; GetColumn = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
If LBound(Arr, 2) &gt; ColumnNumber Then
&nbsp;&nbsp;&nbsp; GetColumn = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

Erase ResultArr
ReDim ResultArr(LBound(Arr, 1) To UBound(Arr, 1))
For RowNdx = LBound(ResultArr) To UBound(ResultArr)
&nbsp;&nbsp;&nbsp; ResultArr(RowNdx) = Arr(RowNdx, ColumnNumber)
Next RowNdx

GetColumn = True


End Function


Function GetRow(Arr As Variant, ResultArr As Variant, RowNumber As Long) As Boolean
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetRow
' This populates ResultArr with a one-dimensional array that is the
' specified row of Arr. The existing contents of ResultArr are
' destroyed. ResultArr must be a dynamic array.
' Returns True or False indicating success.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Dim ColNdx As Long
''''''''''''''''''''''''''''''
' Ensure Arr is an array.
''''''''''''''''''''''''''''''
If IsArray(Arr) = False Then
&nbsp;&nbsp;&nbsp; GetRow = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure Arr is a two-dimensional
' array.
''''''''''''''''''''''''''''''''''
If NumberOfArrayDimensions(Arr) &lt;&gt; 2 Then
&nbsp;&nbsp;&nbsp; GetRow = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''
' Ensure ResultArr is a dynamic
' array.
''''''''''''''''''''''''''''''''''
If IsArrayDynamic(ResultArr) = False Then
&nbsp;&nbsp;&nbsp; GetRow = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

''''''''''''''''''''''''''''''''''''
' Ensure ColumnNumber is less than
' or equal to the number of columns.
''''''''''''''''''''''''''''''''''''
If UBound(Arr, 1) &lt; RowNumber Then
&nbsp;&nbsp;&nbsp; GetRow = False
&nbsp;&nbsp;&nbsp; Exit Function
End If
If LBound(Arr, 1) &gt; RowNumber Then
&nbsp;&nbsp;&nbsp; GetRow = False
&nbsp;&nbsp;&nbsp; Exit Function
End If

Erase ResultArr
ReDim ResultArr(LBound(Arr, 2) To UBound(Arr, 2))
For ColNdx = LBound(ResultArr) To UBound(ResultArr)
&nbsp;&nbsp;&nbsp; ResultArr(ColNdx) = Arr(RowNumber, ColNdx)
Next ColNdx

GetRow = True


End Function

</font></pre><pre></pre><p>&nbsp;</p>
	</td>
    <td width="10%">
      &nbsp;</td>
  </tr>
  <tr>
    <td width="5%"></td>
    <td width="1%">
      <blockquote>
        <p>&nbsp;</p>
      </blockquote>
    </td>
  </tr>
  <tr>
    <td width="5%">&nbsp;</td>
    <td width="93%">
    &nbsp;</td>
    <td width="1%">
      &nbsp;</td>
  </tr>
  <tr>
    <td width="5%">&nbsp;</td>
    <td width="93%">
    &nbsp;</td>
    <td width="1%">
      &nbsp;</td>
  </tr>
</tbody></table>
<p align="center">&nbsp;
</p><p align="center" style="border-style: double; border-color: #800000"><font face="Arial" size="1" color="#800000"><b>Created By Chip Pearson and 
Pearson Software Consulting, LLC&nbsp;</b><br>
This Page:&nbsp;&nbsp;
<script language="JScript">
<!--
document.write (document.URL);
// -->
    </script>http://www.cpearson.com/excel/vbaarrays.htm
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Updated: <!--webbot bot="Timestamp" s-type="EDITED" s-format="%B %d, %Y" startspan -->November 06, 2013<!--webbot bot="Timestamp" i-checksum="39719" endspan -->&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
<a href="http://www.cpearson.com/excel.htm">MAIN PAGE</a>&nbsp;&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/about.htm">About This Site</a>&nbsp;&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/consult.htm">Consulting</a>&nbsp;&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/download.htm">Downloads</a>&nbsp;&nbsp; <br>
<a href="http://www.cpearson.com/excel/ExcelPages.htm">Page Index</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/search.htm">Search</a>&nbsp;&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/topic.htm">Topic Index</a>&nbsp;&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/whatsnew.htm">What's New<span style="text-decoration: none">&nbsp;&nbsp;&nbsp;
</span></a></font><font face="Arial" size="1"><a href="http://www.cpearson.com/excel/links.htm">Links</a>&nbsp;&nbsp;
<a href="http://www.cpearson.com/excel/LegaleseAndDisclaimers.htm">Legalese And Disclaimers</a></font><br>
<font face="Arial" size="2" color="#800000">
<a href="mailto:chip@cpearson.com?subject=Site%20Feedback">chip@cpearson.com</a></font><br>
<font face="Arial" size="1" color="#800000"><br>
 Copyright 1997-2007&nbsp; Charles H. Pearson&nbsp; <br>
<br>
<script type="text/javascript" src="./VBA Arrays_files/show_ads.js">
</script><ins id="aswift_0_expand" style="display:inline-table;border:none;height:undefinedpx;margin:0;padding:0;position:relative;visibility:visible;width:undefinedpx;background-color:transparent"><ins id="aswift_0_anchor" style="display:block;border:none;height:undefinedpx;margin:0;padding:0;position:relative;visibility:visible;width:undefinedpx;background-color:transparent"><iframe width="undefined" height="undefined" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;"></iframe></ins></ins>

<!-- GOOGLE 1 -->
<script type="text/javascript"><!--
    google_ad_client = "pub-7293698002238456";
    google_ad_width = 728;
    google_ad_height = 90;
    google_ad_format = "728x90_as";
    google_ad_type = "text_image";
    google_ad_channel = "";
//--></script><script type="text/javascript" src="./VBA Arrays_files/show_ads.js">
</script><ins id="aswift_1_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_1_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe width="728" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;"></iframe></ins></ins>
<!-- END GOOGLE 1 -->
<!-- GOOGLE 2 -->
<script type="text/javascript"><!--
    google_ad_client = "pub-7293698002238456";
    google_ad_width = 728;
    google_ad_height = 90;
    google_ad_format = "728x90_as";
    google_ad_type = "text_image";
    google_ad_channel = "";
//--></script><script type="text/javascript" src="./VBA Arrays_files/show_ads.js">
</script><ins id="aswift_2_expand" style="display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><ins id="aswift_2_anchor" style="display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:728px;background-color:transparent"><iframe width="728" height="90" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;"></iframe></ins></ins>
</font></p><font face="Arial" size="1" color="#800000">
<!-- END GOOGLE2 -->

</font><div id="goog_qs_tidbit_box" style="display:none"><div id="goog_qs-wrapper"><div id="goog_qs-box-toggle" style="background-image: url(chrome-extension://okanipcmceoeemlbjnmnbdibhgpbllgc/images/close.png);"></div><div id="goog_qs-box-info" class="goog_qs-box-title" style="background-image: url(chrome-extension://okanipcmceoeemlbjnmnbdibhgpbllgc/images/icon16x16.png);"><span class="goog_qs-nowrap">R<img>olagem</span> <span class="goog_qs-nowrap">r<img>pida</span> <span class="goog_qs-nowrap">d<img>o</span> <span class="goog_qs-nowrap">G<img>oogle</span></div><div id="goog_qs-box-tidbits"><div id="goog_qs-box-msg"><span class="goog_qs-nowrap">E<img>sta</span> <span class="goog_qs-nowrap">p<img>gina</span> <span class="goog_qs-nowrap">i<img>nteira</span> <span class="goog_qs-nowrap">p<img>arece</span> <span class="goog_qs-nowrap">s<img>er</span> <span class="goog_qs-nowrap">s<img>obre</span> <span class="goog_qs-query"><span class="goog_qs-nowrap">v<img>ba</span> <span class="goog_qs-nowrap">a<img>rray</span></span>. A <span class="goog_qs-nowrap">R<img>olagem</span> <span class="goog_qs-nowrap">r<img>pida</span> <span class="goog_qs-nowrap">a<img>parece</span> <span class="goog_qs-nowrap">q<img>uando</span> <span class="goog_qs-nowrap">a<img>penas</span> <span class="goog_qs-nowrap">a<img>lgumas</span> <span class="goog_qs-nowrap">p<img>artes</span> <span class="goog_qs-nowrap">d<img>a</span> <span class="goog_qs-nowrap">p<img>gina</span> <span class="goog_qs-nowrap">s<img>o</span> <span class="goog_qs-nowrap">r<img>elevantes.</span> <span class="goog_qs-learn-more"><span class="goog_qs-nowrap">S<img>aiba</span> <span class="goog_qs-nowrap">m<img>ais.</span></span></div></div></div></div></body></html>